<!DOCTYPE html>
<html lang="default">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="baidu-site-verification" content="code-dlFXc2180h" />


    <!-- <meta name="google-site-verification" content="qlTU_n7RT-JIFfLGMsgqxNsTEkVlsWnOfvoPzzHzSR0" /> -->
    <meta name="google-site-verification" content="wNw6ZIFTz_hFtiJ2w108gXZcLcg3e8tLeSGIC36Wn_M" />


    <meta name="author" content="许">





<title>备考2021年12月CSP学习笔记 | 须臾所学之野</title>



    <link rel="icon" href="/favicon.png">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    






    
    
        <script>
    MathJax = {
        tex: {
            // 行内公式标志
            inlineMath: [
                ['$', '$']
            ],
            // 块级公式标志
            displayMath: [
                ['$$', '$$']
            ],
            // 下面两个主要是支持渲染某些公式，可以自己了解
            processEnvironments: true,
            processRefs: true,
        },
        options: {
            // 跳过渲染的标签
            skipHtmlTags: ['noscript', 'style', 'textarea', 'pre', 'code'],
            // 跳过mathjax处理的元素的类名，任何元素指定一个类 tex2jax_ignore 将被跳过，多个累=类名'class1|class2'
            ignoreHtmlClass: 'tex2jax_ignore',
        },
        // 这里可能是因为我的MathJax2仍有残留，导致行间公式被渲染成了type="math/tex"，所以要用这种2、3版本混合查找方式进行渲染
        // 这样可能效率低，有机会再改。
        options: {
            renderActions: {
                /* add a new named action not to override the original 'find' action */
                find_script_mathtex: [10, function (doc) {
                    for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                        const display = !!node.type.match(/; *mode=display/);
                        const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                        const text = document.createTextNode('');
                        node.parentNode.replaceChild(text, node);
                        math.start = {
                            node: text,
                            delim: '',
                            n: 0
                        };
                        math.end = {
                            node: text,
                            delim: '',
                            n: 0
                        };
                        doc.math.push(math);
                    }
                }, '']
            }
        },
        svg: {
            fontCache: 'global',
        },
    };
</script>

<script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>

<!-- <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.bootcdn.net/ajax/libs/mathjax/3.1.2/es5/tex-mml-chtml.min.js">
</script> -->
    



<meta name="generator" content="Hexo 5.4.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Xuwp&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/link">Links</a>
                
                    <a class="menu-item" href="https://xuwp.top/cv-en/">Resume</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Xuwp&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/link">Links</a>
                
                    <a class="menu-item" href="https://xuwp.top/cv-en/">Resume</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6;    // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function () {
            tocbot.refresh(obj_merge(tocbot_default_config, { hasInnerContainers: true }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function () {
        tocbot.init(obj_merge(tocbot_default_config, { collapseDepth: 1 }));
    });

    function expandToc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, { collapseDepth: expanded ? 1 : DEPTH_MAX }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">备考2021年12月CSP学习笔记</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">许</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">November 28, 2021&nbsp;&nbsp;1:44:56</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/">算法竞赛</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <blockquote>
<p>结语：第24次CSP认证尘埃落定，210分，并不很理想，甚至没有我大一时考的高，但并不能认为自己退步了，因为近年的T2都有30%的卡常数据。T4、T5我也都写出了暴力解法，保守能过25+12分的点，但本次比赛最后一个小时一直waiting，心态崩掉了，也不知道该改哪里。学如逆水行舟，不进则退。退的不多又何尝不是一种进步呢？</p>
</blockquote>
<h1 id="202109"><a href="#202109" class="headerlink" title="202109"></a>202109</h1><h2 id="第1题"><a href="#第1题" class="headerlink" title="第1题"></a>第1题</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="http://118.190.20.162/view.page?gpid=T129">202109-1 数组推导</a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>$A_1, A_2, \cdots, A_n$ 是一个由 $n$ 个<strong>自然数</strong>（即非负整数）组成的数组。在此基础上，我们用数组 $B_1 \cdots B_n$ 表示 $A$ 的前缀最大值。</p>
<script type="math/tex; mode=display">
B_i = \max \left\{ A_1, A_2,  \cdots, A_i \right\}</script><p>如上所示，$B_i$ 定义为数组 $A$ 中前 $i$ 个数的最大值。<br>根据该定义易知 $A_1 = B_1$，且随着 $i$ 的增大，$B_i$ 单调不降。<br>此外，我们用 $sum = A_1 + A_2 + \cdots + A_n$ 表示数组 $A$ 中 $n$ 个数的总和。</p>
<p>现已知数组 $B$，我们想要根据 $B$ 的值来反推数组 $A$。<br>显然，对于给定的 $B$，$A$ 的取值可能并不唯一。<br>试计算，在数组 $A$ 所有可能的取值情况中，$sum$ 的最大值和最小值分别是多少？</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>从标准输入读入数据。</p>
<p>输入的第一行包含一个正整数 $n$。</p>
<p>输入的第二行包含 $n$ 个用空格分隔的自然数 $B_1, B_2, \cdots, B_n$。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出到标准输出。</p>
<p>输出共两行。</p>
<p>第一行输出一个整数，表示 $sum$ 的最大值。</p>
<p>第二行输出一个整数，表示 $sum$ 的最小值。</p>
<h3 id="样例1输入"><a href="#样例1输入" class="headerlink" title="样例1输入"></a>样例1输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">0 0 5 5 10 10</span><br></pre></td></tr></table></figure>
<h3 id="样例1输出"><a href="#样例1输出" class="headerlink" title="样例1输出"></a>样例1输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">30</span><br><span class="line">15</span><br></pre></td></tr></table></figure>
<h3 id="样例1解释"><a href="#样例1解释" class="headerlink" title="样例1解释"></a>样例1解释</h3><p>数组 $A$ 的可能取值包括但不限于以下三种情况。</p>
<p>情况一：$A = [0, 0, 5, 5, 10, 10]$</p>
<p>情况二：$A = [0, 0, 5, 3, 10, 4]$</p>
<p>情况三：$A = [0, 0, 5, 0, 10, 0]$</p>
<p>其中第一种情况 $sum = 30$ 为最大值，第三种情况 $sum = 15$ 为最小值。</p>
<h3 id="样例2输入"><a href="#样例2输入" class="headerlink" title="样例2输入"></a>样例2输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">10 20 30 40 50 60 75</span><br></pre></td></tr></table></figure>
<h3 id="样例2输出"><a href="#样例2输出" class="headerlink" title="样例2输出"></a>样例2输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">285</span><br><span class="line">285</span><br></pre></td></tr></table></figure>
<h3 id="样例2解释"><a href="#样例2解释" class="headerlink" title="样例2解释"></a>样例2解释</h3><p>$A = [10, 20, 30, 40, 50, 60, 75]$ 是唯一可能的取值，所以 $sum$ 的最大、最小值均为 $285$。</p>
<h3 id="子任务"><a href="#子任务" class="headerlink" title="子任务"></a>子任务</h3><p>$50%$ 的测试数据满足数组 $B$ 单调递增，即 $0 &lt; B_1 &lt; B_2 &lt; \cdots &lt; B_n &lt; 10^{5}$；</p>
<p>全部的测试数据满足 $n \le 100$ 且数组 $B$ 单调不降，即 $0 \le B_1 \le B_2 \le \cdots \le B_n \le 10^{5}$。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>由题意，显然有$0\le A_i\le B_i$，当想要得到最大值时，只需令$A_i=B_i$，此时的数组$A_1, A_2, \cdots, A_n=B_1 \cdots B_n$，当想要得到最小值时，只需令</p>
<script type="math/tex; mode=display">
A_i=\left\{
\begin{aligned}
0 & , & B_{i-1} = B_i \\
B_i & , & B_{i-1}< B_i 
\end{aligned}
\right.</script><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">b=[<span class="built_in">int</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line">max_sum=<span class="built_in">sum</span>(b)</span><br><span class="line">min_sum=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,<span class="number">1</span>-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> b[i-<span class="number">1</span>]&gt;=b[i]:</span><br><span class="line">        min_sum+=<span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        min_sum+=b[i]</span><br><span class="line">min_sum+=b[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(max_sum)</span><br><span class="line"><span class="built_in">print</span>(min_sum)</span><br></pre></td></tr></table></figure>
<h1 id="202104"><a href="#202104" class="headerlink" title="202104"></a>202104</h1><h2 id="第1题-1"><a href="#第1题-1" class="headerlink" title="第1题"></a>第1题</h2><h3 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="http://118.190.20.162/view.page?gpid=T128">202104-1 灰度直方图</a></p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>一幅长宽分别为 $n$ 个像素和 $m$ 个像素的灰度图像可以表示为一个 $n×m$ 大小的矩阵 $A$。<br>其中每个元素 $Aij$（$0≤i&lt;n$、$0≤j&lt;m$）是一个 $[0,L)$ 范围内的整数，表示对应位置像素的灰度值。<br>具体来说，一个 $8$ 比特的灰度图像中每个像素的灰度范围是 $[0,128)$。</p>
<p>一副灰度图像的灰度统计直方图（以下简称“直方图”）可以表示为一个长度为 $L$ 的数组 $h$，其中 $h[x]$（$0≤x&lt;L$）表示该图像中灰度值为 $x$ 的像素个数。显然，$h[0]$ 到 $h[L−1]$ 的总和应等于图像中的像素总数 $n⋅m$。</p>
<p>已知一副图像的灰度矩阵 $A$，试计算其灰度直方图 $h[0],h[1],⋯,h[L−1]$。</p>
<h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入共 $n+1$ 行。</p>
<p>输入的第一行包含三个用空格分隔的正整数 $n$、$m$ 和 $L$，含义如前文所述。</p>
<p>第 $2$ 到第 $n+1$ 行输入矩阵 $A$。<br>第 $i+2$（$0≤i&lt;n$）行包含用空格分隔的 $m$ 个整数，依次为 $A<em>{i0},A</em>{i1},⋯,A_{i(m−1)}$。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出仅一行，包含用空格分隔的 $L$ 个整数 $h[0],h[1],⋯,h[L−1]$，表示输入图像的灰度直方图。</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 4 16</span><br><span class="line">0 1 2 3</span><br><span class="line">4 5 6 7</span><br><span class="line">8 9 10 11</span><br><span class="line">12 13 14 15</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span><br></pre></td></tr></table></figure>
<h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 11 8</span><br><span class="line">0 7 0 0 0 7 0 0 7 7 0</span><br><span class="line">7 0 7 0 7 0 7 0 7 0 7</span><br><span class="line">7 0 0 0 7 0 0 0 7 0 7</span><br><span class="line">7 0 0 0 0 7 0 0 7 7 0</span><br><span class="line">7 0 0 0 0 0 7 0 7 0 0</span><br><span class="line">7 0 7 0 7 0 7 0 7 0 0</span><br><span class="line">0 7 0 0 0 7 0 0 7 0 0</span><br></pre></td></tr></table></figure>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">48 0 0 0 0 0 0 29</span><br></pre></td></tr></table></figure>
<h3 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h3><p>全部的测试数据满足 $0&lt;n,m≤500$ 且 $4≤L≤256$。</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>模拟题</p>
<p>根据题意构建各变量然后统计即可。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n,m,L=<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">A=[]</span><br><span class="line">h=[<span class="number">0</span>]*L</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    A+=[<span class="built_in">int</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> A:</span><br><span class="line">    h[a]+=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>,h)))</span><br></pre></td></tr></table></figure>
<h2 id="第2题"><a href="#第2题" class="headerlink" title="第2题"></a>第2题</h2><h3 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="http://118.190.20.162/view.page?gpid=T127">202104-2 邻域均值</a></p>
<h3 id="试题背景"><a href="#试题背景" class="headerlink" title="试题背景"></a>试题背景</h3><p>顿顿在学习了数字图像处理后，想要对手上的一副灰度图像进行降噪处理。不过该图像仅在较暗区域有很多噪点，如果贸然对全图进行降噪，会在抹去噪点的同时也模糊了原有图像。因此顿顿打算先使用<strong>邻域均值</strong>来判断一个像素是否处于<strong>较暗区域</strong>，然后仅对处于<strong>较暗区域</strong>的像素进行降噪处理。</p>
<h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>待处理的灰度图像长宽皆为 $n$ 个像素，可以表示为一个 $n×n$ 大小的矩阵 $A$，其中每个元素是一个 $[0,L)$ 范围内的整数，表示对应位置像素的灰度值。<br>对于矩阵中任意一个元素 $Aij(0≤i,j&lt;n)$，其<strong>邻域</strong>定义为附近若干元素的集合：</p>
<script type="math/tex; mode=display">
Neighbor(i, j, r) = \left\{ A_{xy} | 0 \le x, y < n \mathrm{~and~} |x-i| \le r \mathrm{~and~} |y-j| \le r \right\}</script><p>这里使用了一个额外的参数 $r$ 来指明 $Aij$ 附近元素的具体范围。根据定义，易知 $Neighbor(i,j,r)$ 最多有 $(2r+1)^2$ 个元素。</p>
<p>如果元素 $Aij$ <strong>邻域</strong>中所有元素的<strong>平均值</strong>小于或等于一个给定的阈值 $t$，我们就认为该元素对应位置的像素处于<strong>较暗区域</strong>。<br>下图给出了两个例子，左侧图像的较暗区域在右侧图像中展示为黑色，其余区域展示为白色。</p>
<p><img src="https://testingcf.jsdelivr.net/gh/WanpengXu/myPicGo/img/202111281731890.jpg" alt=""></p>
<p>现给定邻域参数 $r$ 和阈值 $t$，试统计输入灰度图像中有多少像素处于<strong>较暗区域</strong>。</p>
<h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入共 $n+1$ 行。</p>
<p>输入的第一行包含四个用空格分隔的正整数 $n、L、r $ 和 $t$，含义如前文所述。</p>
<p>第二到第 $n+1$ 行输入矩阵 $A$。<br>第 $i+2(0≤i&lt;n)$ 行包含用空格分隔的$n$个整数，依次为 $Ai0,Ai1,⋯,Ai(n−1)$。</p>
<h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示输入灰度图像中处于较暗区域的像素总数。</p>
<h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 16 1 6</span><br><span class="line">0 1 2 3</span><br><span class="line">4 5 6 7</span><br><span class="line">8 9 10 11</span><br><span class="line">12 13 14 15</span><br></pre></td></tr></table></figure>
<h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>
<h3 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">11 8 2 2</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 7 0 0 0 7 0 0 7 7 0</span><br><span class="line">7 0 7 0 7 0 7 0 7 0 7</span><br><span class="line">7 0 0 0 7 0 0 0 7 0 7</span><br><span class="line">7 0 0 0 0 7 0 0 7 7 0</span><br><span class="line">7 0 0 0 0 0 7 0 7 0 0</span><br><span class="line">7 0 7 0 7 0 7 0 7 0 0</span><br><span class="line">0 7 0 0 0 7 0 0 7 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0</span><br></pre></td></tr></table></figure>
<h3 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">83</span><br></pre></td></tr></table></figure>
<h3 id="评测用例规模与约定-1"><a href="#评测用例规模与约定-1" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h3><p>70% 的测试数据满足 $n≤100$、$r≤10$。</p>
<p>全部的测试数据满足 $0&lt;n≤600$、$0&lt;r≤100$ 且 $2≤t&lt;L≤256$。</p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>题目要求计算领域均值，那么首先要计算的是<script type="math/tex">\sum{Neighbor(i, j, r)}</script>，其次是$|Neighbor(i,j,r)|$，对于<script type="math/tex">\sum{Neighbor(i, j, r)}</script>，不难发现，如果对每一个元素进行暴力求解，将会计算大量重复区域，这样的话我们可以使用<strong>二维前缀和</strong>方法，即对于一个矩阵 $a$，我们定义一个矩阵 $psum$，使得 <script type="math/tex">psum_{x,y}=\sum\limits_{i=1}^{x}\sum\limits_{j=1}^{y}a_{i,j}</script>，那么，要求解某一个特定的子矩阵的和，只需使用容斥原理即可。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">n,L,r,t=<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">A=[[<span class="number">0</span>]*(n+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    A.append([<span class="number">0</span>]+[<span class="built_in">int</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">input</span>().split()])</span><br><span class="line">psum=[[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        psum[i][j]=psum[i-<span class="number">1</span>][j]+psum[i][j-<span class="number">1</span>]-psum[i-<span class="number">1</span>][j-<span class="number">1</span>]+A[i][j]</span><br><span class="line">num=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        w=<span class="built_in">max</span>(j-r,<span class="number">1</span>)</span><br><span class="line">        s=<span class="built_in">min</span>(j+r,n)</span><br><span class="line">        a=<span class="built_in">max</span>(i-r,<span class="number">1</span>)</span><br><span class="line">        d=<span class="built_in">min</span>(i+r,n)</span><br><span class="line">        st=(psum[d][s]-psum[d][w-<span class="number">1</span>]-psum[a-<span class="number">1</span>][s]+psum[a-<span class="number">1</span>][w-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> st&lt;=t*((s-w+<span class="number">1</span>)*(d-a+<span class="number">1</span>)):</span><br><span class="line">            num+=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure>
<h2 id="第3题"><a href="#第3题" class="headerlink" title="第3题"></a>第3题</h2><h3 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="http://118.190.20.162/view.page?gpid=T126"> 202104-3 DHCP服务器</a></p>
<h3 id="试题背景-1"><a href="#试题背景-1" class="headerlink" title="试题背景"></a>试题背景</h3><p><strong>动态主机配置协议</strong>（Dynamic Host Configuration Protocol, DHCP）是一种自动为网络客户端分配 IP 地址的网络协议。当支持该协议的计算机刚刚接入网络时，它可以启动一个 DHCP 客户端程序。后者可以通过一定的网络报文交互，从 DHCP 服务器上获得 IP 地址等网络配置参数，从而能够在用户不干预的情况下，自动完成对计算机的网络设置，方便用户连接网络。DHCP 协议的工作过程如下：</p>
<ol>
<li>当 DHCP 协议启动的时候，DHCP 客户端向网络中广播发送 Discover 报文，请求 IP 地址配置；</li>
<li>当 DHCP 服务器收到 Discover 报文时，DHCP 服务器根据报文中的参数选择一个尚未分配的 IP 地址，分配给该客户端。DHCP 服务器用 Offer 报文将这个信息传达给客户端；</li>
<li>客户端收集收到的 Offer 报文。由于网络中可能存在多于一个 DHCP 服务器，因此客户端可能收集到多个 Offer 报文。客户端从这些报文中选择一个，并向网络中广播 Request 报文，表示选择这个 DHCP 服务器发送的配置；</li>
<li>DHCP 服务器收到 Request 报文后，首先判断该客户端是否选择本服务器分配的地址：如果不是，则在本服务器上解除对那个 IP 地址的占用；否则则再次确认分配的地址有效，并向客户端发送 Ack 报文，表示确认配置有效，Ack 报文中包括配置的有效时间。如果 DHCP 发现分配的地址无效，则返回 Nak 报文；</li>
<li>客户端收到 Ack 报文后，确认服务器分配的地址有效，即确认服务器分配的地址未被其它客户端占用，则完成网络配置，同时记录配置的有效时间，出于简化的目的，我们不考虑被占用的情况。若客户端收到 Nak 报文，则从步骤 1 重新开始；</li>
<li>客户端在到达配置的有效时间前，再次向 DHCP 服务器发送 Request 报文，表示希望延长 IP 地址的有效期。DHCP 服务器按照步骤 4 确定是否延长，客户端按照步骤 5 处理后续的配置；</li>
</ol>
<p>在本题目中，你需要理解 DHCP 协议的工作过程，并按照题目的要求实现一个简单的 DHCP 服务器。</p>
<h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><h4 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h4><p>为了便于实现，我们简化地规定 DHCP 数据报文的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;发送主机&gt; &lt;接收主机&gt; &lt;报文类型&gt; &lt;IP 地址&gt; &lt;过期时刻&gt;</span><br></pre></td></tr></table></figure>
<p>DHCP 数据报文的各个部分由空格分隔，其各个部分的定义如下：</p>
<ul>
<li>发送主机：是发送报文的主机名，<strong>主机名</strong>是由小写字母、数字组成的字符串，唯一地表示了一个主机；</li>
<li>接收主机：当有特定的接收主机时，是接收报文的主机名；当没有特定的接收主机时，为一个星号（<code>*</code>）；</li>
<li>报文类型：是三个大写字母，取值如下：<ul>
<li><code>DIS</code>：表示 Discover 报文；</li>
<li><code>OFR</code>：表示 Offer 报文；</li>
<li><code>REQ</code>：表示 Request 报文；</li>
<li><code>ACK</code>：表示 Ack 报文；</li>
<li><code>NAK</code>：表示 Nak 报文；</li>
</ul>
</li>
<li>IP 地址，是一个非负整数：<ul>
<li>对于 Discover 报文，该部分在发送的时候为 0，在接收的时候忽略；</li>
<li>对于其它报文，为正整数，表示一个 IP 地址；</li>
</ul>
</li>
<li>过期时刻，是一个非负整数：<ul>
<li>对于 Offer、Ack 报文，是一个正整数，表示服务器授予客户端的 IP 地址的过期时刻；</li>
<li>对于 Discover、Request 报文，若为正整数，表示客户端期望服务器授予的过期时刻；</li>
<li>对于其它报文，该部分在发送的时候为 0，在接收的时候忽略。</li>
</ul>
</li>
</ul>
<p>例如下列都是合法的 DHCP 数据报文：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a * DIS 0 0</span><br><span class="line">d a ACK 50 1000</span><br></pre></td></tr></table></figure>
<h4 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h4><p>为了 DHCP 服务器能够正确分配 IP 地址，DHCP 需要接受如下配置：</p>
<ul>
<li>地址池大小 N：表示能够分配给客户端的 IP 地址的数目，且能分配的 IP 地址是 1,2,…,N；</li>
<li>默认过期时间 Tdef：表示分配给客户端的 IP 地址的默认的过期时间长度；</li>
<li>过期时间的上限和下限 Tmax、Tmin：表示分配给客户端的 IP 地址的最长过期时间长度和最短过期时间长度，客户端不能请求比这个更长或更短的过期时间；</li>
<li>本机名称 H：表示运行 DHCP 服务器的主机名。</li>
</ul>
<h4 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h4><p>当客户端请求 IP 地址时，首先检查此前是否给该客户端分配过 IP 地址，且该 IP 地址在此后没有被分配给其它客户端。如果是这样的情况，则直接将 IP 地址分配给它，否则，<br>总是分配给它最小的尚未占用过的那个 IP 地址。如果这样的地址不存在，则分配给它最小的此时未被占用的那个 IP 地址。如果这样的地址也不存在，说明地址池已经分配完毕，因此拒绝分配地址。</p>
<h4 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h4><p>在 DHCP 启动时，首先初始化 IP 地址池，将所有地址设置状态为未分配，占用者为空，并清零过期时刻。<br>其中地址的状态有未分配、待分配、占用、过期四种。<br>处于未分配状态的 IP 地址没有占用者，而其余三种状态的 IP 地址均有一名占用者。<br>处于待分配和占用状态的 IP 地址拥有一个大于零的过期时刻。在到达该过期时刻时，若该地址的状态是待分配，则该地址的状态会自动变为未分配，且占用者清空，过期时刻清零；否则该地址的状态会由占用自动变为过期，且过期时刻清零。处于未分配和过期状态的 IP 地址过期时刻为零，即没有过期时刻。</p>
<p>对于收到的报文，设其收到的时刻为 t。处理细节如下：</p>
<ol>
<li>判断接收主机是否为本机，或者为 <code>*</code>，若不是，则判断类型是否为 Request，若不是，则不处理；</li>
<li>若类型不是 Discover、Request 之一，则不处理；</li>
<li>若接收主机为 <code>*</code>，但类型不是 Discover，或接收主机是本机，但类型是 Discover，则不处理。</li>
</ol>
<p>对于 Discover 报文，按照下述方法处理：</p>
<ol>
<li>检查是否有占用者为发送主机的 IP 地址：<ul>
<li>若有，则选取该 IP 地址；</li>
<li>若没有，则选取最小的状态为未分配的 IP 地址；</li>
<li>若没有，则选取最小的状态为过期的 IP 地址；</li>
<li>若没有，则不处理该报文，处理结束；</li>
</ul>
</li>
<li>将该 IP 地址状态设置为待分配，占用者设置为发送主机；</li>
<li>若报文中过期时刻为 0 ，则设置过期时刻为 t+Tdef；否则根据报文中的过期时刻和收到报文的时刻计算过期时间，判断是否超过上下限：若没有超过，则设置过期时刻为报文中的过期时刻；否则则根据超限情况设置为允许的最早或最晚的过期时刻；</li>
<li>向发送主机发送 Offer 报文，其中，IP 地址为选定的 IP 地址，过期时刻为所设定的过期时刻。</li>
</ol>
<p>对于 Request 报文，按照下述方法处理：</p>
<ol>
<li>检查接收主机是否为本机：<ul>
<li>若不是，则找到占用者为发送主机的所有 IP 地址，对于其中状态为待分配的，将其状态设置为未分配，并清空其占用者，清零其过期时刻，处理结束；</li>
</ul>
</li>
<li>检查报文中的 IP 地址是否在地址池内，且其占用者为发送主机，若不是，则向发送主机发送 Nak 报文，处理结束；</li>
<li>无论该 IP 地址的状态为何，将该 IP 地址的状态设置为占用；</li>
<li>与 Discover 报文相同的方法，设置 IP 地址的过期时刻；</li>
<li>向发送主机发送 Ack 报文。</li>
</ol>
<p>上述处理过程中，地址池中地址的状态的变化可以概括为如下图所示的状态转移图。为了简洁，该图中没有涵盖需要回复 Nak 报文的情况。</p>
<p><img src="https://testingcf.jsdelivr.net/gh/WanpengXu/myPicGo/img/202111281721522.jfif" alt=""></p>
<h3 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行包含用空格分隔的四个正整数和一个字符串，分别是：N、Tdef、Tmax、Tmin 和 H，保证 Tmin≤Tdef≤Tmax。</p>
<p>输入的第二行是一个正整数 n，表示收到了 n 个报文。</p>
<p>输入接下来有 n 行，第 (i+2) 行有空格分隔的正整数 ti 和约定格式的报文 Pi。表示收到的第 i 个报文是在 ti 时刻收到的，报文内容是 Pi。保证 ti&lt;ti+1。</p>
<h3 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出有若干行，每行是一个约定格式的报文。依次输出 DHCP 服务器发送的报文。</p>
<h3 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">4 5 10 5 dhcp</span><br><span class="line">16</span><br><span class="line">1 a * DIS 0 0</span><br><span class="line">2 a dhcp REQ 1 0</span><br><span class="line">3 b a DIS 0 0</span><br><span class="line">4 b * DIS 3 0</span><br><span class="line">5 b * REQ 2 12</span><br><span class="line">6 b dhcp REQ 2 12</span><br><span class="line">7 c * DIS 0 11</span><br><span class="line">8 c dhcp REQ 3 11</span><br><span class="line">9 d * DIS 0 0</span><br><span class="line">10 d dhcp REQ 4 20</span><br><span class="line">11 a dhcp REQ 1 20</span><br><span class="line">12 c dhcp REQ 3 20</span><br><span class="line">13 e * DIS 0 0</span><br><span class="line">14 e dhcp REQ 2 0</span><br><span class="line">15 b dhcp REQ 2 25</span><br><span class="line">16 b * DIS 0 0</span><br></pre></td></tr></table></figure>
<h3 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dhcp a OFR 1 6</span><br><span class="line">dhcp a ACK 1 7</span><br><span class="line">dhcp b OFR 2 9</span><br><span class="line">dhcp b ACK 2 12</span><br><span class="line">dhcp c OFR 3 12</span><br><span class="line">dhcp c ACK 3 13</span><br><span class="line">dhcp d OFR 4 14</span><br><span class="line">dhcp d ACK 4 20</span><br><span class="line">dhcp a ACK 1 20</span><br><span class="line">dhcp c ACK 3 20</span><br><span class="line">dhcp e OFR 2 18</span><br><span class="line">dhcp e ACK 2 19</span><br><span class="line">dhcp b NAK 2 0</span><br></pre></td></tr></table></figure>
<h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><p>输入第一行，分别设置了 DHCP 的相关参数，并收到了 16 个报文。</p>
<p>第 1 个报文和第 2 个报文是客户端 <code>a</code> 正常请求地址，服务器为其分配了地址 1，相应地设置了过期时刻是 7（即当前时刻 2 加上默认过期时间 5）。</p>
<p>第 3 个报文不符合 Discover 报文的要求，不做任何处理。</p>
<p>第 4 个报文 <code>b</code> 发送的 Discover 报文虽然有 IP 地址 3，但是按照处理规则，这个字段被忽略，因此服务器返回 Offer 报文，过期时刻是 9。</p>
<p>第 5 个报文中，Request 报文不符合接收主机是 DHCP 服务器本机的要求，因此不做任何处理。</p>
<p>第 6 个报文是 <code>b</code> 发送的 Request 报文，其中设置了过期时刻是 12，没有超过最长过期时间，因此返回的 Ack 报文中过期时刻也是 12。</p>
<p>第 7 个报文中，过期时刻 11 小于最短过期时间，因此返回的过期时刻是 12。虽然此时为 <code>a</code> 分配的地址 1 过期，但是由于还有状态为未分配的地址 3，因此为 <code>c</code> 分配地址 3。第 8 个报文同理，为 <code>c</code> 分配的地址过期时刻是 13。</p>
<p>第 9、10 两个报文中，为 <code>d</code> 分配了地址 4，过期时刻是 20。</p>
<p>第 11 个报文中，<code>a</code> 请求重新获取此前为其分配的地址 1，虽然为其分配的地址过期，但是由于尚未分配给其它客户端，因此 DHCP 服务器可以直接为其重新分配该地址，并重新设置过期时刻为 20。</p>
<p>第 12 个报文中，<code>c</code> 请求延长其地址的过期时刻为 20。DHCP 正常向其回复 Ack 报文。</p>
<p>第 13、14 个报文中，<code>e</code> 试图请求地址。此时地址池中已经没有处于“未分配”状态的地址了，但是有此前分配给 <code>b</code> 的地址 2 的状态是“过期”，因此把该地址重新分配给 <code>e</code>。</p>
<p>第 15 个报文中，<code>b</code> 试图重新获取此前为其分配的地址 2，但是此时该地址已经被分配给 <code>e</code>，因此返回 Nak 报文。</p>
<p>第 16 个报文中，<code>b</code> 试图重新请求分配一个 IP 地址，但是此时地址池中已经没有可用的地址了，因此忽略该请求。</p>
<h3 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4 70 100 50 dhcp</span><br><span class="line">6</span><br><span class="line">5 a * OFR 2 100</span><br><span class="line">10 b * DIS 0 70</span><br><span class="line">15 b dhcp2 REQ 4 60</span><br><span class="line">20 c * DIS 0 70</span><br><span class="line">70 d * DIS 0 120</span><br><span class="line">75 d dhcp REQ 1 125</span><br></pre></td></tr></table></figure>
<h3 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dhcp b OFR 1 70</span><br><span class="line">dhcp c OFR 1 70</span><br><span class="line">dhcp d OFR 1 120</span><br><span class="line">dhcp d ACK 1 125</span><br></pre></td></tr></table></figure>
<h3 id="样例说明-1"><a href="#样例说明-1" class="headerlink" title="样例说明"></a>样例说明</h3><p>在本样例中，DHCP 服务器一共收到了 6 个报文，处理情况如下：</p>
<p>第 1 个报文不是 DHCP 服务器需要处理的报文，因此不回复任何报文。</p>
<p>第 2 个报文中，<code>b</code> 请求分配 IP 地址，因此 DHCP 服务器将地址 1 分配给 <code>b</code>，此时，地址 1 进入待分配状态，DHCP 服务器向 <code>b</code> 发送 Offer 报文。</p>
<p>第 3 个报文中，<code>b</code> 发送的 REQ 报文是发给非本服务器的，因此需要将地址池中所有拥有者是 <code>b</code> 的待分配状态的地址修改为未分配。</p>
<p>第 4 个报文中，<code>c</code> 请求分配 IP 地址。由于地址 1 此时是未分配状态，因此将该地址分配给它，向它发送 Offer 报文，地址 1 进入待分配状态。</p>
<p>第 5、6 个报文中，<code>d</code> 请求分配 IP 地址。注意到在收到第 5 个报文时，已经是时刻 70，地址 1 的过期时刻已到，它的状态已经被修改为了未分配，因此 DHCP 服务器仍然将地址 1 分配给 <code>d</code>。</p>
<h3 id="评测用例规模与约定-2"><a href="#评测用例规模与约定-2" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h3><p>对于 20% 的数据，有 N≤200，且 n≤N，且输入仅含 Discover 报文，且 t&lt;Tmin；</p>
<p>对于 50% 的数据，有 N≤200，且 n≤N，且 t&lt;Tmin，且报文的接收主机或为本机，或为 <code>*</code>；</p>
<p>对于 70% 的数据，有 N≤1000，且 n≤N，且报文的接收主机或为本机，或为 <code>*</code>；</p>
<p>对于 100% 的数据，有 N≤10000，且 n≤10000，主机名的长度不超过 20，且 t,Tmin,Tdefault,Tmax≤109，输入的报文格式符合题目要求，且数字不超过 109。</p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>模拟就是用计算机来模拟题目中要求的操作。</p>
<p>大模拟，也就是复杂模拟题，是CSP中T3的的固定题型。</p>
<p>代码对应的要求已经注释在了旁边，故这里略。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipAddress</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">    <span class="keyword">int</span> state;  <span class="comment">// 1:未分配, 2:待分配, 3:占用, 4:过期</span></span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line">ipAddress ipPool[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, tdef, tmax, tmin;</span><br><span class="line">    string host;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; tdef &gt;&gt; tmax &gt;&gt; tmin &gt;&gt; host;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        ipPool[i].state = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n2;</span><br><span class="line">    cin &gt;&gt; n2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n2; k++) &#123;</span><br><span class="line">        string lhost, rhost, type;</span><br><span class="line">        <span class="keyword">int</span> seq, ip, time;</span><br><span class="line">        cin &gt;&gt; seq &gt;&gt; lhost &gt;&gt; rhost &gt;&gt; type &gt;&gt; ip &gt;&gt; time;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 在到达该过期时刻时</span></span><br><span class="line">            <span class="keyword">if</span> (ipPool[i].time &lt;= seq) &#123;</span><br><span class="line">                <span class="comment">// 若该地址的状态是待分配，则该地址的状态会自动变为未分配，且占用者清空，过期时刻清零；</span></span><br><span class="line">                <span class="keyword">if</span> (ipPool[i].state == <span class="number">2</span>) &#123;</span><br><span class="line">                    ipPool[i].state = <span class="number">1</span>;</span><br><span class="line">                    ipPool[i].name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    ipPool[i].time = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 否则该地址的状态会由占用自动变为过期，且过期时刻清零。</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ipPool[i].state == <span class="number">3</span>) &#123;</span><br><span class="line">                    ipPool[i].state = <span class="number">4</span>;</span><br><span class="line">                    ipPool[i].time = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于收到的报文</span></span><br><span class="line">        <span class="comment">// 判断接收主机是否为本机，或者为 *，若不是，则判断类型是否为 Request，若不是，则不处理；</span></span><br><span class="line">        <span class="comment">// 这里判断类型是否为 Request是在或条件后面，本身就是前两个都为假才判断的，可以写在一行</span></span><br><span class="line">        <span class="keyword">if</span> ((rhost == host || rhost == <span class="string">&quot;*&quot;</span>) || type == <span class="string">&quot;REQ&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">// 若类型不是 Discover、Request 之一，则不处理；</span></span><br><span class="line">            <span class="keyword">if</span> (type != <span class="string">&quot;DIS&quot;</span> &amp;&amp; type != <span class="string">&quot;REQ&quot;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 若接收主机为 *，但类型不是 Discover，或接收主机是本机，但类型是 Discover，则不处理。</span></span><br><span class="line">            <span class="keyword">if</span> ((rhost == <span class="string">&quot;*&quot;</span> &amp;&amp; type != <span class="string">&quot;DIS&quot;</span>) || (rhost == host &amp;&amp; type == <span class="string">&quot;DIS&quot;</span>))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 对于 Discover 报文</span></span><br><span class="line">            <span class="keyword">if</span> (type == <span class="string">&quot;DIS&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> select = <span class="number">-1</span>;</span><br><span class="line">                <span class="comment">// 检查是否有占用者为发送主机的 IP 地址</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                    <span class="comment">// 若有，则选取该 IP 地址；</span></span><br><span class="line">                    <span class="comment">// 加一条，IP地址应为未分配的</span></span><br><span class="line">                    <span class="keyword">if</span> (ipPool[i].name == lhost &amp;&amp; ipPool[i].state != <span class="number">1</span>) &#123;</span><br><span class="line">                        select = i;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="comment">// 若没有，则选取最小的状态为未分配的 IP 地址；</span></span><br><span class="line">                <span class="keyword">if</span> (select == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                        <span class="keyword">if</span> (ipPool[i].state == <span class="number">1</span>) &#123;</span><br><span class="line">                            select = i;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 若没有，则选取最小的状态为过期的 IP 地址；</span></span><br><span class="line">                <span class="keyword">if</span> (select == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                        <span class="keyword">if</span> (ipPool[i].state == <span class="number">4</span>) &#123;</span><br><span class="line">                            select = i;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (select != <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 将该 IP 地址状态设置为待分配，占用者设置为发送主机；</span></span><br><span class="line">                    ipPool[select].state = <span class="number">2</span>;</span><br><span class="line">                    ipPool[select].name = lhost;</span><br><span class="line">                    <span class="comment">// 若报文中过期时刻为 0 ，则设置过期时刻为t+T_def；</span></span><br><span class="line">                    <span class="keyword">if</span> (time == <span class="number">0</span>)</span><br><span class="line">                        ipPool[select].time = seq + tdef;</span><br><span class="line">                    <span class="comment">// 否则根据报文中的过期时刻和收到报文的时刻计算过期时间，判断是否超过上下限：</span></span><br><span class="line">                    <span class="comment">// 计算方法：过期时刻-收到时刻=过期时间</span></span><br><span class="line">                    <span class="comment">// 若没有超过，则设置过期时刻为报文中的过期时刻；</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (tmin &lt;= time - seq &amp;&amp; time - seq &lt;= tmax)</span><br><span class="line">                        ipPool[select].time = time;</span><br><span class="line">                    <span class="comment">// 若没有超过，则设置过期时刻为报文中的过期时刻；</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (time - seq &lt; tmin)</span><br><span class="line">                        ipPool[select].time = seq + tmin;</span><br><span class="line">                    <span class="comment">// 否则则根据超限情况设置为允许的最早或最晚的过期时刻；</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (time - seq &gt; tmax)</span><br><span class="line">                        ipPool[select].time = seq + tmax;</span><br><span class="line">                    <span class="comment">// 向发送主机发送 Offer 报文，其中，IP 地址为选定的 IP 地址，过期时刻为所设定的过期时刻。</span></span><br><span class="line">                    cout &lt;&lt; host &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; lhost &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;OFR&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; select &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ipPool[select].time &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对于 Request 报文</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">&quot;REQ&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 检查接收主机是否为本机：</span></span><br><span class="line">                <span class="keyword">if</span> (rhost != host) &#123;</span><br><span class="line">                    <span class="comment">// 若不是，则找到占用者为发送主机的所有 IP 地址，对于其中状态为待分配的，将其状态设置为未分配，并清空其占用者，清零其过期时刻，处理结束；</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                        <span class="keyword">if</span> (ipPool[i].name == lhost &amp;&amp; ipPool[i].state == <span class="number">2</span>) &#123;</span><br><span class="line">                            ipPool[i].state = <span class="number">1</span>;</span><br><span class="line">                            ipPool[i].name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                            ipPool[i].time = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 检查报文中的 IP 地址是否在地址池内，且其占用者为发送主机</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">1</span> &lt;= ip &amp;&amp; ip &lt;= n &amp;&amp; ipPool[ip].name == lhost) &#123;</span><br><span class="line">                        <span class="comment">// 无论该 IP 地址的状态为何，将该 IP 地址的状态设置为占用；</span></span><br><span class="line">                        ipPool[ip].state = <span class="number">3</span>;</span><br><span class="line">                        <span class="comment">// 与 Discover 报文相同的方法，设置 IP 地址的过期时刻；</span></span><br><span class="line">                        <span class="keyword">if</span> (time == <span class="number">0</span>)</span><br><span class="line">                            ipPool[ip].time = seq + tdef;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (tmin &lt;= time - seq &amp;&amp; time - seq &lt;= tmax)</span><br><span class="line">                            ipPool[ip].time = time;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (time - seq &lt; tmin)</span><br><span class="line">                            ipPool[ip].time = seq + tmin;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (time - seq &gt; tmax)</span><br><span class="line">                            ipPool[ip].time = seq + tmax;</span><br><span class="line">                        <span class="comment">// 向发送主机发送 Ack 报文。</span></span><br><span class="line">                        cout &lt;&lt; host &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; lhost &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;ACK&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ipPool[ip].time &lt;&lt; endl;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//若不是，则向发送主机发送 Nak 报文，处理结束；</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        cout &lt;&lt; host &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; lhost &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;NAK&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第4题"><a href="#第4题" class="headerlink" title="第4题"></a>第4题</h2><h3 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="http://118.190.20.162/view.page?gpid=T125">202104-4 校门外的树</a></p>
<h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>X 校最近打算美化一下校园环境。前段时间因为修地铁，X 校大门外种的行道树全部都被移走了。现在 X 校打算重新再种一些树，为校园增添一抹绿意。</p>
<p>X 校大门外的道路是东西走向的，我们可以将其看成一条数轴。在这条数轴上有 n 个障碍物，例如电线杆之类的。虽然障碍物会影响树的生长，但是障碍物不一定能被随便移走，所以 X 校规定在障碍物的位置上<strong>不能</strong>种树。n 个障碍物的坐标都是整数；如果规定向东为正方向，则 n 个障碍物的坐标按照从西到东的顺序分别为 a1,a2,⋯,an。X 校打算在 [a1,an] 之间种一些树，使得这些树看起来比较美观。</p>
<p>X 校希望，在一定范围内，树应该是等间隔的。更具体地说，如果把 [a1,an) 划分成一些区间 [ap1,ap2),⋯,[apm−1,apm)（1=p1&lt;p2&lt;⋯&lt;pm=n），那么每个区间 [api,api+1) 内需要至少种一棵树，且该区间内种的树的坐标连同区间端点 api,api+1 应该构成一个等差数列。不同区间的公差，也就是树的间隔可以不相同。</p>
<p>例如，如果障碍物位于 0,2,6 这三处，那么我们可以选择在 [0,2) 和 [2,6) 分别种树，也可以选择在 [0,6) 等间隔种树。如果是分别在 [0,2) 和 [2,6) 种树，由于每个区间内至少要种一棵树，坐标 1 上必须种树；而 [2,6) 上的树可以按照 1 的间隔种下，也可以按照 2 的间隔种下。下图表示了这两种美观的种树方案，其中橙色的圆表示障碍物，绿色的圆表示需要在这个位置种树，箭头上的数字表示种下这棵树时对应的间隔为多少。</p>
<p><img src="https://testingcf.jsdelivr.net/gh/WanpengXu/myPicGo/img/202111280209683.png" alt=""></p>
<p>对区间 [0,2) 和 [2,6) 分别以 1 和 2 的间隔种树是美观的</p>
<p><img src="https://testingcf.jsdelivr.net/gh/WanpengXu/myPicGo/img/202111280048528.png" alt=""></p>
<p>对区间 [0,2) 和 [2,6) 分别以 1 的间隔种树也是美观的</p>
<p>而如果选择在 [0,6) 区间等间隔种树，我们只能以 3 的间隔种树，因为无论是选择间隔 1 或者间隔 2，都需要在坐标 2 上种树，而这个位置已经有障碍物了。下图分别表示了间隔为 3,2,1 时的种树情况，红色箭头表示不能在这里种树。</p>
<p><img src="https://testingcf.jsdelivr.net/gh/WanpengXu/myPicGo/img/202111281919845.png" alt=""></p>
<p>对区间 [0,6) 以 3 的间隔种树是美观的</p>
<p><img src="https://testingcf.jsdelivr.net/gh/WanpengXu/myPicGo/img/202111280049170.png" alt=""></p>
<p>对区间 [0,6) 以 2 的间隔种树是不美观的</p>
<p><img src="https://testingcf.jsdelivr.net/gh/WanpengXu/myPicGo/img/202111281921265.png" alt=""></p>
<p>对区间 [0,6) 以 1 的间隔种树也是不美观的</p>
<p>一般地，给定一个区间 $[al,ar)$，对于树的坐标的集合 $T⊂(al,ar)(T⊂Z)$，归纳定义 $T$ 在 $[al,ar)$ 上是<strong>美观的</strong>：</p>
<ol>
<li>如果 $T≠∅$，$T∩{al,al+1,⋯,ar}=∅$，并且存在一个公差 $d≥1$，使得 $T∪{al,ar}$ 中的元素按照从小到大的顺序排序后，可以构成一个公差为 $d$ 的等差数列（显然，这个等差数列的首项为 $al$，末项为 $ar$），则 $T$ 在 $[al,ar)$ 上是美观的；</li>
<li>如果 $T∩{al,al+1,⋯,ar}=∅$，并且存在一个下标 $m（l&lt;m&lt;r）$，使得 $T∩(al,am)$ 在 $[al,am)$ 上是美观的，且 $T∩(am,ar)$ 在 $[am,ar)$ 上是美观的，则 $T$ 在 $[al,ar)$ 上是美观的。</li>
</ol>
<p>根据这一定义，空集在任意区间上都不是美观的；另外，如果存在下标 $i$ 使得 $ai∈T$，那么 $T$ 一定不是美观的。</p>
<p>我们称两种种树的方案是<strong>本质不同的</strong>，当且仅当两种方案中，种树的坐标集合不同。请帮助 X 校对 $[a1,an)$ 求出所有本质不同的美观的种树方案。当然，由于方案可能很多，你只需要输出总方案数对 $10^9+7$ 取模的结果。</p>
<h3 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行包含一个正整数 $n$，表示障碍物的数量。</p>
<p>输入的第二行包括 $n$ 个非负整数 $a1,⋯,an$，表示每个障碍物的坐标。</p>
<p>保证对 $i=1,2,⋯,n−1$，$ai&lt;ai+1$。</p>
<h3 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个非负整数，表示本质不同的美观的种树方案的数量对 $10^9+7$ 取模的结果。</p>
<h3 id="样例输入-6"><a href="#样例输入-6" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">0 2 6</span><br></pre></td></tr></table></figure>
<h3 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="样例说明-2"><a href="#样例说明-2" class="headerlink" title="样例说明"></a>样例说明</h3><p>这组样例即为题面描述中提到的那组。</p>
<h3 id="样例输入-7"><a href="#样例输入-7" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11</span><br><span class="line">0 10 20 30 40 50 60 70 80 90 100</span><br></pre></td></tr></table></figure>
<h3 id="样例输出-7"><a href="#样例输出-7" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">256507</span><br></pre></td></tr></table></figure>
<h3 id="样例输入-8"><a href="#样例输入-8" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">333</span><br><span class="line">33 44 67 210 528 762 873 984 1234 1466 1739 2859 3421 4061 4598 5172 5201 5220 5261 5322 5389 5559 6670 7070 7898 8079 8129 8192 8616 8641 8806 9559 9585 9750 10263 10627 10674 10692 10903 11649 11885 12179 12307 12743 13173 13352 13389 13496 13611 15292 15321 16018 16327 16415 16959 16972 17499 17617 17786 18476 18966 19239 19498 19875 20312 20392 21603 21620 21730 21967 21972 21999 22015 22590 22775 23709 23839 24165 24408 24595 25160 25479 25812 26482 27328 28101 28297 28305 28342 28557 28986 29110 29401 29765 30292 30493 30739 31027 31201 31218 31414 32089 32759 32770 32777 32815 32877 32890 33297 33457 33603 33757 33866 34498 34525 34659 34679 34861 34870 34997 35311 35846 36411 36457 36738 36902 37940 38228 40156 40320 40705 40737 40803 41066 41443 41460 41954 41968 42040 42062 42099 43281 43320 43527 43537 43587 43729 44750 44822 45655 45769 46109 46525 47060 47128 47999 48635 48887 48981 49366 49424 49524 50546 50580 50689 51332 51861 51943 52097 52702 53009 53067 53397 53526 53901 54280 54399 54801 55535 55592 55740 55843 56110 56428 56552 56682 56848 57179 57688 57797 57847 57959 58330 58831 59553 59699 59884 59939 61233 61636 61732 61908 62145 62549 62649 62740 62912 62971 63053 64312 64322 64412 64816 64845 64873 64923 64976 65023 65166 65496 66065 66491 66803 66941 67081 68331 68336 68360 68476 69179 69719 69758 69948 70072 70544 70598 70990 71014 71454 71687 71743 71958 72282 72384 72456 72985 73327 74325 75046 75097 76647 77062 77088 77431 77553 77673 77753 78217 78518 78564 79565 79588 79686 80275 80939 81052 81348 81386 81440 81589 81610 81793 82408 82801 82836 83239 83466 83610 83867 83943 84441 84467 85248 85305 85554 85565 85758 86251 86603 86743 87323 87565 87824 87833 88265 88309 89178 89509 89618 89699 89708 90331 90359 90878 90902 91449 92284 92374 92549 92609 93609 94345 94934 95140 95475 95733 95985 95995 96270 96641 96807 97003 97632 98160 98677 98853 98943 99037 99055 99075 99185 99395 99592</span><br></pre></td></tr></table></figure>
<h3 id="样例输出-8"><a href="#样例输出-8" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7094396</span><br></pre></td></tr></table></figure>
<h3 id="评测用例规模与约定-3"><a href="#评测用例规模与约定-3" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h3><p>对于 10% 的数据，保证 n=2；</p>
<p>对于 30% 的数据，保证 n≤10；</p>
<p>对于 60% 的数据，保证 n≤100,ai≤1000；</p>
<p>对于 100% 的数据，保证 2≤n≤1000,0≤ai≤100,000，且至少存在一种美观的种树方案。</p>
<h3 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h3><p>动态规划+打表</p>
<p>设$dp[i]$为到第i个障碍物之间的方案总数，那么有状态转移方程</p>
<script type="math/tex; mode=display">
dp[i]=\sum\limits_{j=1}^{i-1}dp[j]\times{calc(j,i)}</script><p>其中$calc(j,i)$为第$j$个障碍物到第$i$个障碍物的方案总数。</p>
<p>为了得出优化的calc函数进行如下分析：</p>
<ol>
<li><p>第j个障碍物到第i个障碍物的间隔必须为obstacles[i]-obstacles[j]的因子，否则树不是等间隔的，挑选撞不上障碍物的因子作为种树方案。</p>
</li>
<li><p>若从j从i-1开始倒着枚举，开始时i-1和i之间没有障碍物，即obstacles[i]-obstacles[i-1]的所有因子都是种树方案，将这些因子设为不可再用(false)，当j=i-2时，对因子进行筛选时不可使用false的因子，因为按这些间隔排序一定会撞到原先作为左端点的障碍物。</p>
<p>所以我们可以从i-1到1遍历j，如果obstacles[i]-obstacles[j]的因子可使用就数量+1并标记为false，否则啥也不干。</p>
<p>注意当i增长时要重置因子可用集合flag为true。</p>
</li>
<li><p>因为我们需要频繁地获取某区间长度的因子，所以可以用筛选法进行预处理，即将因子打个表</p>
<p>这个表可以从1打到最大长度AMAX，也可以进行时间复杂度的优化，因为</p>
<ol>
<li>种树间隔不会超过最大障碍物距离的一半</li>
<li>种树的区间不会超过最大障碍物距离</li>
</ol>
<p>注：最大障碍物距离只是我形象的说法，其实比真实的最大障碍物距离大，因为坐标0不一定有障碍物。</p>
</li>
</ol>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define DEBUG  // 定义空的宏，只可判断其是否被定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> AMAX = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, obstacles[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[N];</span><br><span class="line"><span class="keyword">bool</span> flag[AMAX];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v[AMAX];  <span class="comment">// 以向量为元素的数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = obstacles[y] - obstacles[x];</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d: v[len])</span><br><span class="line">        <span class="keyword">if</span> (flag[d]) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            flag[d] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    flag[len] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;obstacles[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定以i(种树间隔)为因数的j</span></span><br><span class="line">    <span class="comment">// 经优化的打表，右界可以直接为AMAX</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= obstacles[n] / <span class="number">2</span>; i++)  <span class="comment">// 间隔不超过最大障碍物距离的一半</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt;= obstacles[n]; j += i)  <span class="comment">// 两障碍物间至少有一颗树，即间隔i不能为j自己（j=ki&lt;=最大障碍物距离,k=2,3,...）</span></span><br><span class="line">            v[j].<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%2d: &quot;</span>, i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>) v[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, v[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// #else</span></span><br><span class="line"><span class="comment">//     printf(&quot;Not debugging\n&quot;);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(flag, <span class="literal">true</span>, <span class="keyword">sizeof</span> flag);  <span class="comment">// 刻板印象：sizeof其实是个关键字！后面括号是提优先级用的！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--)</span><br><span class="line">            dp[i] = (dp[i] + dp[j] * <span class="built_in">calc</span>(j, i)) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, dp[n]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h3><ol>
<li><p>宏定义可以定义一个空的宏，如<code>#define DEBUG</code>，这种宏只能被用来判断是否被定义，常用于DEBUG时运行一些不想在RELEASE运行的语句</p>
<p>使用方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    定义了DEBUG时要做的</span><br><span class="line">[</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	没定义DEBUG时要做的</span><br><span class="line">]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>sizeof</code>其实是个关键字，一直认为它是函数的原因在于它经常加括号使用以区分操作对象</p>
<p>举个例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span> p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span> p+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span> (p+<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">9</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<p>注：%zd是sizeof的返回类型unsigned int的输出控制符</p>
</li>
</ol>
<h1 id="202012"><a href="#202012" class="headerlink" title="202012"></a>202012</h1><h2 id="期末预测之安全指数"><a href="#期末预测之安全指数" class="headerlink" title="期末预测之安全指数"></a>期末预测之安全指数</h2><h3 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="http://118.190.20.162/view.page?gpid=T123">202012-1 期末预测之安全指数</a></p>
<h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><p>考虑到安全指数是一个较大范围内的整数、小菜很可能搞不清楚自己是否真的安全，顿顿决定设置一个阈值 $θ$，以便将安全指数 $y$ 转化为一个具体的预测结果——“会挂科”或“不会挂科”。</p>
<p>因为安全指数越高表明小菜同学挂科的可能性越低，所以当 $y≥θ$ 时，顿顿会预测小菜这学期很安全、不会挂科；反之若 $y&lt;θ$，顿顿就会劝诫小菜：“你期末要挂科了，勿谓言之不预也。”</p>
<p>那么这个阈值该如何设定呢？顿顿准备从过往中寻找答案。</p>
<h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>具体来说，顿顿评估了 $m$ 位同学上学期的安全指数，其中第 $i$（$1≤i≤m$）位同学的安全指数为 $y_i$，是一个 $[0,108]$ 范围内的整数；同时，该同学上学期的挂科情况记作 $resulti∈0,1$，其中 $0$ 表示挂科、$1$ 表示未挂科。</p>
<p>相应地，顿顿用 <script type="math/tex">predict_{\theta} ( y )</script> 表示根据阈值 $θ$ 将安全指数 $y$ 转化为的具体预测结果。<br>如果 <script type="math/tex">predict_{\theta} ( y_j )</script> 与 $result_j$ 相同，则说明阈值为 $θ$ 时顿顿对第 $j$ 位同学是否挂科预测正确；不同则说明预测错误。</p>
<script type="math/tex; mode=display">
\mathrm{predict}_{\theta} ( y ) = \left\{
\begin{array}{cc}
0& {(y < \theta)}
\\1& {(y \ge \theta)}
\end{array}
\right.</script><p>最后，顿顿设计了如下公式来计算最佳阈值 $\theta^*$：</p>
<script type="math/tex; mode=display">
\theta^* = \max { \mathop{\mathrm{argmax} }\limits_{\theta \in { y_i } } \sum\limits_{j=1}^{m} ( \mathrm{predict}_{\theta} ( y_j ) == result_j ) }</script><p>该公式亦可等价地表述为如下规则：</p>
<ol>
<li>最佳阈值仅在 ${ y_i }$ 中选取，即与某位同学的安全指数相同；</li>
<li>按照该阈值对这 $m$ 位同学上学期的挂科情况进行预测，预测正确的次数最多（即准确率最高）；</li>
<li>多个阈值均可以达到最高准确率时，选取其中最大的。</li>
</ol>
<h3 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h3><p>从标准输入读入数据。</p>
<p>输入的第一行包含一个正整数 $m$。</p>
<p>接下来输入 $m$ 行，其中第 $i$（$1≤i≤m$）行包括用空格分隔的两个整数 $y_i$ 和 $result_i$，含义如上文所述。</p>
<h3 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出到标准输出。</p>
<p>输出一个整数，表示最佳阈值 $\theta^∗$。</p>
<h3 id="样例1输入-1"><a href="#样例1输入-1" class="headerlink" title="样例1输入"></a>样例1输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">0 0</span><br><span class="line">1 0</span><br><span class="line">1 1</span><br><span class="line">3 1</span><br><span class="line">5 1</span><br><span class="line">7 1</span><br></pre></td></tr></table></figure>
<h3 id="样例1输出-1"><a href="#样例1输出-1" class="headerlink" title="样例1输出"></a>样例1输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="样例1解释-1"><a href="#样例1解释-1" class="headerlink" title="样例1解释"></a>样例1解释</h3><p>按照规则一，最佳阈值的选取范围为 $0,1,3,5,7$。</p>
<p>$θ=0$ 时，预测正确次数为 $4$；</p>
<p>$θ=1$ 时，预测正确次数为 $5$；</p>
<p>$θ=3$ 时，预测正确次数为 $5$；</p>
<p>$θ=5$ 时，预测正确次数为 $4$；</p>
<p>$θ=7$ 时，预测正确次数为 $3$。</p>
<p>阈值选取为 $1$ 或 $3$ 时，预测准确率最高；<br>所以按照规则二，最佳阈值的选取范围缩小为 $1$,$3$。</p>
<p>依规则三，$\theta^* = \max { 1, 3 } = 3$。</p>
<h3 id="样例2输入-1"><a href="#样例2输入-1" class="headerlink" title="样例2输入"></a>样例2输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">5 1</span><br><span class="line">5 0</span><br><span class="line">5 0</span><br><span class="line">2 1</span><br><span class="line">3 0</span><br><span class="line">4 0</span><br><span class="line">100000000 1</span><br><span class="line">1 0</span><br></pre></td></tr></table></figure>
<h3 id="样例2输出-1"><a href="#样例2输出-1" class="headerlink" title="样例2输出"></a>样例2输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100000000</span><br></pre></td></tr></table></figure>
<h3 id="子任务-1"><a href="#子任务-1" class="headerlink" title="子任务"></a>子任务</h3><p>$70\%$ 的测试数据保证 $m≤200$；</p>
<p>全部的测试数据保证 $2≤m≤105$。</p>
<h3 id="问题分析-2"><a href="#问题分析-2" class="headerlink" title="问题分析"></a>问题分析</h3><p>模拟一个加权公式</p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    w,score=<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">    <span class="built_in">sum</span>+=w*score</span><br><span class="line">y=<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">sum</span>)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure>
<h2 id="期末预测之最佳阈值"><a href="#期末预测之最佳阈值" class="headerlink" title="期末预测之最佳阈值"></a>期末预测之最佳阈值</h2><h3 id="题目链接-6"><a href="#题目链接-6" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="http://118.190.20.162/view.page?gpid=T122"> 202012-2 期末预测之最佳阈值</a></p>
<h3 id="问题分析-3"><a href="#问题分析-3" class="headerlink" title="问题分析"></a>问题分析</h3><p>前缀和、后缀和</p>
<p>根据题意和用例规模可以知道很容易写出70分的$O(n^2)$解，其主要优化点在于：</p>
<ol>
<li>怎样跳过的相同安全指数$y_i$</li>
<li>怎样在遍历时确定选定阈值对应的预测正确次数</li>
</ol>
<p>不难发现，第一份代码中对于优化点1将<script type="math/tex">y_i</script>和<script type="math/tex">y_{i-1}</script>对比，如果相同则跳过<script type="math/tex">y_i</script>，对于优化点2没做处理，暴力地使用了遍历，在$O(n)$的时间内获取到了预测正确次数，很容易知道在阈值变为下一个的时候，前后两段的预测正确者重合度很高，对于这种情况一般可以使用前/后缀和+容斥原理（本题是一维列表，未用到容斥原理）进行优化。</p>
<p>第二份代码对于优化点1建立了一个“相等值的下标列表”，对于相等的几个安全指数采用第一个安全指数的下标，对于优化点2，使用前缀和及后缀和在$O(1)$的时间内获取到了预测正确次数。</p>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><p>$O(n^2)$的70分解</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">m=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">y=[<span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)]</span><br><span class="line">result=[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    y_i,result_i=<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">    y.append(y_i)</span><br><span class="line">    result.append(result_i)</span><br><span class="line">best_theta=<span class="number">0</span></span><br><span class="line">best_num=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i,y_i <span class="keyword">in</span> <span class="built_in">enumerate</span>(y[<span class="number">1</span>:],<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> y_i==y[i-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    num=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> y[j]&lt;y_i <span class="keyword">and</span> result[j]==<span class="number">0</span>:</span><br><span class="line">            num+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> y[j]&gt;=y_i <span class="keyword">and</span> result[j]==<span class="number">1</span>:</span><br><span class="line">            num+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> num&gt;best_num:</span><br><span class="line">        best_theta=y_i</span><br><span class="line">        best_num=num</span><br><span class="line">    <span class="keyword">elif</span> num==best_num:</span><br><span class="line">        best_theta=<span class="built_in">max</span>(best_theta,y_i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(best_theta)</span><br></pre></td></tr></table></figure>
<p>$O(n)$的100分解</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">m=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">a=[]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    a.append([<span class="built_in">int</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">input</span>().split()])</span><br><span class="line">a.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line">a=[[<span class="number">0</span>,<span class="number">0</span>]]+a</span><br><span class="line">prefix=[<span class="number">0</span>]*(m+<span class="number">1</span>)</span><br><span class="line">suffix=[<span class="number">0</span>]*(m+<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">    prefix[i]=prefix[i-<span class="number">1</span>]+(<span class="number">1</span> <span class="keyword">if</span> a[i][<span class="number">1</span>]==<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m,<span class="number">1</span>-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">    suffix[i]=suffix[i+<span class="number">1</span>]+(<span class="number">1</span> <span class="keyword">if</span> a[i][<span class="number">1</span>]==<span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">pos=<span class="number">1</span></span><br><span class="line">equal_position=[<span class="number">0</span>]*(m+<span class="number">1</span>)  <span class="comment"># 相等值的下标列表</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span>(a[i][<span class="number">0</span>]==a[i-<span class="number">1</span>][<span class="number">0</span>]):</span><br><span class="line">        equal_position[i]=pos</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pos=i</span><br><span class="line">        equal_position[i]=pos</span><br><span class="line"></span><br><span class="line">best_theta=<span class="number">0</span></span><br><span class="line">best_num=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">    current_num=prefix[equal_position[i]-<span class="number">1</span>]+suffix[i]</span><br><span class="line">    <span class="keyword">if</span> current_num&gt;=best_num:</span><br><span class="line">        best_num=current_num</span><br><span class="line">        best_theta=a[i][<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(best_theta)</span><br></pre></td></tr></table></figure>
<h1 id="202006"><a href="#202006" class="headerlink" title="202006"></a>202006</h1><h2 id="线性分类器"><a href="#线性分类器" class="headerlink" title="线性分类器"></a>线性分类器</h2><h3 id="题目链接-7"><a href="#题目链接-7" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="http://118.190.20.162/view.page?gpid=T105">202006-1 线性分类器</a></p>
<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>简单模拟</p>
<p>按类别将输入分好类</p>
<p>然后使用judgeX函数分别判断A类B类点代入后是否都具有相同的符号。</p>
<p>这里用到了一点高中数学的知识，在同一侧的点代入函数后都应该有相同的符号，至于在某一侧是否有固定的符号我记不清了，所以我先获取了第一个点代入后的符号，然后看后面的点是否都跟这个符号相等，其实这两个符号应该是正负相反的，但是数据集好像没有考这里，有点混乱，做出来就行。</p>
<h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">n,m=<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">pointsA=[]</span><br><span class="line">pointsB=[]</span><br><span class="line">lines=[]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">judgeX</span>(<span class="params">X</span>):</span></span><br><span class="line">    pointsX=pointsA <span class="keyword">if</span> X==<span class="string">&#x27;A&#x27;</span> <span class="keyword">else</span> pointsB</span><br><span class="line">    point=pointsX[<span class="number">0</span>]</span><br><span class="line">    part1=<span class="number">1</span> <span class="keyword">if</span> line[<span class="number">0</span>]+line[<span class="number">1</span>]*point[<span class="number">0</span>]+line[<span class="number">2</span>]*point[<span class="number">1</span>]&gt;<span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> point <span class="keyword">in</span> pointsX[<span class="number">1</span>:]:</span><br><span class="line">        part2=<span class="number">1</span> <span class="keyword">if</span> line[<span class="number">0</span>]+line[<span class="number">1</span>]*point[<span class="number">0</span>]+line[<span class="number">2</span>]*point[<span class="number">1</span>]&gt;<span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> part2!=part1:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    expoint=<span class="built_in">input</span>().split()</span><br><span class="line">    point=[<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> expoint[:<span class="number">2</span>]]</span><br><span class="line">    <span class="keyword">if</span> expoint[<span class="number">2</span>]==<span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        pointsA.append(point)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pointsB.append(point)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    line=[<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line">    lines.append(line)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    <span class="keyword">if</span> judgeX(<span class="string">&#x27;A&#x27;</span>) <span class="keyword">and</span> judgeX(<span class="string">&#x27;B&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Yes&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;No&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="稀疏向量"><a href="#稀疏向量" class="headerlink" title="稀疏向量"></a>稀疏向量</h2><h3 id="题目链接-8"><a href="#题目链接-8" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="http://118.190.20.162/view.page?gpid=T104">202006-2 稀疏向量</a></p>
<h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>基本思路是用映射把稀疏向量保存起来，只有两个向量的键上都有值时才求他们值的乘积，其余情况的乘积都是0，那么可以使用集合求键的交集来实现找相同元素，解法一基于此思路，但这样要考虑到求交集所需的时间，据<a target="_blank" rel="noopener" href="https://wiki.python.org/moin/TimeComplexity">python wiki</a>，<code>Intersection s&amp;t</code>的平均时间复杂度为<code>O(min(len(s), len(t))</code>，而解法二的<code>k in d</code>的平均时间复杂度为<code>O(1)</code>，所以我们可以把“求交”替换为“属于”。</p>
<p><img src="https://testingcf.jsdelivr.net/gh/WanpengXu/myPicGo/img/202112041918065.png" alt=""></p>
<p><img src="https://testingcf.jsdelivr.net/gh/WanpengXu/myPicGo/img/202112041918633.png" alt=""></p>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><p>90分解</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">n,a,b=<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">vector1=&#123;&#125;</span><br><span class="line">v1index=<span class="built_in">set</span>()</span><br><span class="line">vector2=&#123;&#125;</span><br><span class="line">v2index=<span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(a):</span><br><span class="line">    indexi,valuei=<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">    vector1[indexi]=valuei</span><br><span class="line">    v1index.add(indexi)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(b):</span><br><span class="line">    indexj,valuej=<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">    vector2[indexj]=valuej</span><br><span class="line">    v2index.add(indexj)</span><br><span class="line">sameindex=<span class="built_in">list</span>(v1index.intersection(v2index))  <span class="comment"># 求交集时间复杂度O(min(len(s), len(t))</span></span><br><span class="line">mul=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> sameindex:</span><br><span class="line">    mul+=vector1[index]*vector2[index]</span><br><span class="line"><span class="built_in">print</span>(mul)</span><br></pre></td></tr></table></figure>
<p>100分解</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n,a,b=<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">vector1=&#123;&#125;</span><br><span class="line">mul=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(a):</span><br><span class="line">    indexi,valuei=<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">    vector1[indexi]=valuei</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(b):</span><br><span class="line">    indexj,valuej=<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">    <span class="keyword">if</span> indexj <span class="keyword">in</span> vector1.keys():</span><br><span class="line">        mul+=vector1[indexj]*valuej</span><br><span class="line"><span class="built_in">print</span>(mul)</span><br></pre></td></tr></table></figure>
<h1 id="201709"><a href="#201709" class="headerlink" title="201709"></a>201709</h1><h2 id="通信网络"><a href="#通信网络" class="headerlink" title="通信网络"></a>通信网络</h2><h3 id="题目链接-9"><a href="#题目链接-9" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="http://118.190.20.162/view.page?gpid=T60">201709-4 通信网络</a></p>
<h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>DFS</p>
<p>一道比较简单的DFS，用C++11风格写的</p>
<p>首先要有</p>
<ol>
<li>一个二维long long向量，用来表示图</li>
<li>一个二维bool向量，用来表示i知道j</li>
<li>一个一维bool向量，用来表示“访问过”，这里本应是二维，为了降低空间复杂度把它设计成了一维，每次将它重新初始化为“未访问过”(false)</li>
</ol>
<p>接着设计一个DFS函数</p>
<ol>
<li>对于进入到函数中的点对，标记为“访问过”（true）</li>
<li>对于进入到函数中的点对，将他们标记为互相知道</li>
<li>对于点对中第一个点的每个出度点，若没被访问过，将他们扔入dfs函数</li>
</ol>
<p>最后在主函数中</p>
<ol>
<li>将输入构造为邻接表（由稀疏向量有感：邻接表其实就是稀疏的邻接矩阵）</li>
<li>将每一个点和它自己扔入dfs函数（每个点肯定知道自己）</li>
<li>最后按行遍历“二维知道向量”，如果某行知道所有点（true的数量等于点的数量），把结果自增1</li>
</ol>
<p>至于为什么这道题不取消visit标记，我不知道。</p>
<h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> ll MAX=<span class="number">1000</span>+<span class="number">5</span>;</span><br><span class="line">ll ni,mi;</span><br><span class="line">vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">graph</span>(MAX);</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">know</span>(MAX,vector&lt;<span class="keyword">bool</span>&gt;(MAX));</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">visit</span><span class="params">(MAX)</span></span>;  <span class="comment">// 邻接表的每行都复用它</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll v,ll s)</span></span>&#123;</span><br><span class="line">    visit[v]=<span class="literal">true</span>;</span><br><span class="line">    know[s][v]=know[v][s]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i:graph[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">not</span> visit[i])</span><br><span class="line">            <span class="built_in">dfs</span>(i,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;ni&gt;&gt;mi;</span><br><span class="line">    <span class="keyword">while</span>(mi--)&#123;</span><br><span class="line">        ll ai,bi;</span><br><span class="line">        cin&gt;&gt;ai&gt;&gt;bi;</span><br><span class="line">        graph[ai].<span class="built_in">push_back</span>(bi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=ni;i++)&#123;</span><br><span class="line">        <span class="built_in">fill</span>(visit.<span class="built_in">begin</span>()+<span class="number">1</span>,visit.<span class="built_in">begin</span>()+ni+<span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(i,i);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=ni;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">count</span>(know[i].<span class="built_in">begin</span>()+<span class="number">1</span>,know[i].<span class="built_in">begin</span>()+ni+<span class="number">1</span>,<span class="literal">true</span>)==ni)</span><br><span class="line">            ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JSON查询"><a href="#JSON查询" class="headerlink" title="JSON查询"></a>JSON查询</h2><h3 id="题目链接-10"><a href="#题目链接-10" class="headerlink" title="题目链接"></a>题目链接</h3><p><a target="_blank" rel="noopener" href="http://118.190.20.162/view.page?gpid=T61">201709-3 JSON查询</a></p>
<h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>震惊我一整年的题，python花活太多了</p>
<p>一个是这个输入正好符合python中dict的样式，可以直接用exec将字符串作为语句执行</p>
<p>第二是可以直接导入json库，用本身的loads函数创建半结构数据</p>
<h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><p>100分法一</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">n,m=<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">op=<span class="string">&#x27;dic=&#x27;</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    op+=<span class="built_in">input</span>()</span><br><span class="line"><span class="built_in">exec</span>(op)  <span class="comment"># 这个执行会自动转义&quot;却不会转义\，奇怪</span></span><br><span class="line"><span class="comment"># print(dic)</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    query=<span class="built_in">input</span>().replace(<span class="string">&quot;\\&quot;</span>,<span class="string">&quot;\\&quot;</span>)  <span class="comment"># 这第二个字符串参数竟然不支持转义</span></span><br><span class="line">    op=<span class="string">&#x27;res=dic&#x27;</span></span><br><span class="line">    obj=query.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> o <span class="keyword">in</span> obj:</span><br><span class="line">        op+=<span class="string">f&#x27;[<span class="subst">&#123;<span class="built_in">repr</span>(o)&#125;</span>]&#x27;</span></span><br><span class="line">    <span class="comment"># print(op)</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">exec</span>(op)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;NOTEXIST&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(res,<span class="built_in">str</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;STRING&#x27;</span>,res)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;OBJECT&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>100分法二</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">json_str = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    json_str += <span class="built_in">input</span>()</span><br><span class="line"></span><br><span class="line">data = json.loads(json_str)  <span class="comment"># 我勒个大草tmd竟然能直接载入</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># type(data) # dict</span></span><br><span class="line"><span class="comment"># print(data)  # &#123;&#x27;firstName&#x27;: &#x27;John&#x27;, &#x27;lastName&#x27;: &#x27;Smith&#x27;, &#x27;address&#x27;: &#123;&#x27;streetAddress&#x27;: &#x27;2ndStreet&#x27;, &#x27;city&#x27;: &#x27;NewYork&#x27;, &#x27;state&#x27;: &#x27;NY&#x27;&#125;, &#x27;esc\\aped&#x27;: &#x27;&quot;hello&quot;&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(type(data[&#x27;firstName&#x27;]))  # &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="comment"># print(type(data[&#x27;address&#x27;]))  # &lt;class &#x27;dict&#x27;&gt;</span></span><br><span class="line"><span class="comment"># print(type(data[&#x27;address&#x27;][&#x27;city&#x27;]))  # &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">querys = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    querys.append(<span class="built_in">input</span>().split(<span class="string">&quot;.&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># json_type=&#123;</span></span><br><span class="line"><span class="comment">#     str:&quot;STRING&quot;,</span></span><br><span class="line"><span class="comment">#     dict:&quot;OBJECT&quot;</span></span><br><span class="line"><span class="comment">#     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> q <span class="keyword">in</span> querys:</span><br><span class="line">    search = <span class="string">&quot;data&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> q:</span><br><span class="line">            search += <span class="string">f&quot;[<span class="subst">&#123;<span class="built_in">repr</span>(x)&#125;</span>]&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(<span class="built_in">eval</span>(search)) == <span class="built_in">str</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;STRING&quot;</span>, <span class="built_in">eval</span>(search))</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">type</span>(<span class="built_in">eval</span>(search)) == <span class="built_in">dict</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;OBJECT&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception:  <span class="comment"># 这里单用KeyError只能得90，还有我没考虑到的异常，为了保险所有异常都从这走</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;NOTEXIST&#x27;</span>)</span><br></pre></td></tr></table></figure>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>许</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://xuwp.top/2021-12-CSP.html">http://xuwp.top/2021-12-CSP.html</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2022 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E7%AE%97%E6%B3%95/"># 算法</a>
                    
                        <a href="/tags/CSP/"># CSP</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/Java-Summary.html">《Java语言及网络编程》课后小结</a>
            
            
            <a class="next" rel="next" href="/undefined.html">Hello World</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>Stay hungry. Stay foolish.</span>
    </div>
</footer>

    </div>
</body>

</html>