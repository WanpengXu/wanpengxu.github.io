<!DOCTYPE html>
<html lang="default">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="许">





<title>《人工智能导论》 | 须臾所学之野</title>



    <link rel="icon" href="/favicon.png">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    


<meta name="generator" content="Hexo 5.4.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Xuwp&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/link">Links</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Xuwp&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/link">Links</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6;    // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function () {
            tocbot.refresh(obj_merge(tocbot_default_config, { hasInnerContainers: true }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function () {
        tocbot.init(obj_merge(tocbot_default_config, { collapseDepth: 1 }));
    });

    function expandToc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, { collapseDepth: expanded ? 1 : DEPTH_MAX }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">《人工智能导论》</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">许</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">May 18, 2022&nbsp;&nbsp;22:38:34</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/AI/">AI</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <blockquote>
<p>人工智能领域的一本经典教材。</p>
<p>作为导论，涵盖知识还是很广泛的。</p>
</blockquote>
<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p>略</p>
<h1 id="知识表示与知识图谱"><a href="#知识表示与知识图谱" class="headerlink" title="知识表示与知识图谱"></a>知识表示与知识图谱</h1><h2 id="知识的概念"><a href="#知识的概念" class="headerlink" title="知识的概念"></a>知识的概念</h2><p>知识：把有关信息关联在一起所形成的信息结构</p>
<p>知识分为“事实”和“规则”。</p>
<p>相对正确性：在一定的条件及环境下，知识一般是正确的。</p>
<p>不确定性：知识不是“真”与“假”的二值结构，“真”与“假”间存在中间状态，“真”是有程度的。</p>
<p>可表示性：知识可以用适当形式表现出来。</p>
<p>可利用性：知识可以被利用。</p>
<p>知识表示：将人类知识形式化或者模型化。</p>
<h2 id="一阶谓词逻辑表示法"><a href="#一阶谓词逻辑表示法" class="headerlink" title="一阶谓词逻辑表示法"></a>一阶谓词逻辑表示法</h2><p>人工智能中的逻辑分为经典命题逻辑和一阶谓词逻辑。</p>
<p>命题（proposition）：一个非真即假的陈述句。通常用大写的英文字母表示。</p>
<p>命题可以在一种条件下为真，在另一种条件下为假。</p>
<p>按抽象与否，命题分为命题常量与命题变元，命题变元只有把确定的命题代入后才有可能具有明确的真值。</p>
<p>原子命题：简单陈述句表达的命题。</p>
<p>复合命题：对原子命题使用连接词构成的命题。</p>
<p>谓词（predicate）：即谓语，分为谓词名与个体两个部分。其一般形式：</p>
<script type="math/tex; mode=display">
P(x_1, x_2, \dots, x_n)</script><p>其中，P是谓词名，$x_1, x_2, \dots, x_n$是个体。</p>
<p>元数：谓词包含的个体数目</p>
<p>项：个体常量、个体变元、函数的统称</p>
<p>个体域：个体变元的取值范围</p>
<p>函数：一种一一映射，其值为个体域中的某个个体</p>
<h3 id="谓词公式"><a href="#谓词公式" class="headerlink" title="谓词公式"></a>谓词公式</h3><h4 id="连接词（按优先级顺序）"><a href="#连接词（按优先级顺序）" class="headerlink" title="连接词（按优先级顺序）"></a>连接词（按优先级顺序）</h4><p>$\neg$：“非”（negation）</p>
<p>$\wedge$：“合取”（conjunction）</p>
<p>$\vee$：“析取”（disjunction）</p>
<p>$\rightarrow$：“蕴涵”（implication），$P\rightarrow Q$：P蕴涵Q，P称前件、Q称后件。</p>
<p>$\leftrightarrow$：“等价”（equivalence）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$P$</th>
<th>$Q$</th>
<th>$\neg P$</th>
<th>$P\vee Q$</th>
<th>$P\wedge Q$</th>
<th>$P\rightarrow Q$</th>
<th>$P\leftrightarrow Q$</th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>T</td>
<td>F</td>
<td>T</td>
<td>T</td>
<td>T</td>
<td>T</td>
</tr>
<tr>
<td>T</td>
<td>F</td>
<td>F</td>
<td>T</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
<tr>
<td>F</td>
<td>T</td>
<td>T</td>
<td>T</td>
<td>F</td>
<td>T</td>
<td>F</td>
</tr>
<tr>
<td>F</td>
<td>F</td>
<td>T</td>
<td>F</td>
<td>F</td>
<td>T</td>
<td>T</td>
</tr>
</tbody>
</table>
</div>
<p>注意：蕴涵的真值，如果前件为假，那么无法判断后件为何值时蕴涵式为假。所以前件为假时蕴涵式为真。</p>
<p>$\forall$：全称量词（universal quantifier）“任意”</p>
<p>$\exists$：存在量词（existential quantifier）“存在”</p>
<p>量词的辖域：量词后的整体谓词公式，辖域内与量词同名的变元称为约束变元，不同名的称为自由变元。</p>
<h4 id="常用等价式"><a href="#常用等价式" class="headerlink" title="常用等价式"></a>常用等价式</h4><p>吸收律：</p>
<script type="math/tex; mode=display">
P\vee (P\wedge Q) \Leftrightarrow P\\
P\wedge (P\vee Q) \Leftrightarrow P</script><p>德摩根律：</p>
<script type="math/tex; mode=display">
\neg(P\vee Q)\Leftrightarrow \neg P \wedge \neg Q\\
\neg(P\wedge Q) \Leftrightarrow \neg P \vee \neg Q</script><p><strong>连接词化归律</strong>：</p>
<script type="math/tex; mode=display">
P\rightarrow Q \Leftrightarrow \neg P \vee Q\\
P\leftrightarrow Q \Leftrightarrow (P\wedge Q)\vee (\neg P \wedge \neg Q)</script><p>量词转换律：</p>
<script type="math/tex; mode=display">
\neg(\exists x)P \Leftrightarrow(\forall x)\neg P\\
\neg(\forall x)P \Leftrightarrow(\exists x)\neg P</script><h4 id="永真蕴涵"><a href="#永真蕴涵" class="headerlink" title="永真蕴涵"></a>永真蕴涵</h4><p>如果$P\rightarrow Q$永真，则$P\Rightarrow Q$</p>
<p>假言推理：又称肯定前件（Modus Ponens）</p>
<script type="math/tex; mode=display">
P, P\rightarrow Q \Rightarrow Q</script><p>拒取式推理：又称否定后件（Modus Tollens）</p>
<script type="math/tex; mode=display">
\neg Q, P\rightarrow Q \Rightarrow \neg P</script><p>（逆否后肯定前件）</p>
<p>假言三段论：</p>
<script type="math/tex; mode=display">
P \rightarrow Q, Q\rightarrow R \Rightarrow P\rightarrow R</script><p>全称固化（全称量词消去，UI）：</p>
<script type="math/tex; mode=display">
(\forall x)P(x) \Rightarrow P(y)</script><p>存在固化（存在量词消去，EI）：</p>
<script type="math/tex; mode=display">
(\exists x)P(x) \Rightarrow P(c)</script><p><strong>反证法</strong>：</p>
<p>$P\Rightarrow Q$，当且仅当$P\wedge \neg Q \Leftrightarrow F$</p>
<p>证明很容易，先把左边化成蕴涵。从左到右：只有P:T Q:F 左式才会F，而P:T Q:F则右侧为真，其余三种情况都为假。从右到左：则P:F Q:T，这是为真的情况。（正式的证明以后再写）</p>
<h2 id="产生式表示法"><a href="#产生式表示法" class="headerlink" title="产生式表示法"></a>产生式表示法</h2><p>确定性规则知识的产生式：</p>
<script type="math/tex; mode=display">
IF \qquad P \qquad THEN\qquad Q</script><p>不确定性规则知识的产生式：</p>
<script type="math/tex; mode=display">
IF \qquad P \qquad THEN\qquad Q\qquad(置信度)</script><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><blockquote>
<p><strong>关于习题部分，书后有详细的答案，而且较为准确，我当时写的比较潦草，所以这里只点出几个值得注意的点。下同。</strong></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205221345658.png" alt=""></p>
<p>2.1 (5)</p>
<p>答案为：</p>
<script type="math/tex; mode=display">
(\forall x )(\neg pass(x,exam(English))\rightarrow \neg study(x,aborad))</script><p>原自然语言表述：要想出国留学，必须通过外语考试。</p>
<p>这里的答案用了一个逆否命题的形式：如果没通过外语考试，那么不能出国留学。</p>
<p>第五版中2.5后新增了一道题：</p>
<p>2.6 用产生式表示：如果一个人发烧、呕吐、出现黄恒，那么得肝炎的可能性有7成。</p>
<script type="math/tex; mode=display">
IF\qquad 此人发烧\qquad AND\qquad 此人呕吐\qquad AND \quad 此人出现黄恒\qquad THEN\quad 此人得了肝炎\qquad(0.7)</script><h1 id="确定性推理方法"><a href="#确定性推理方法" class="headerlink" title="确定性推理方法"></a>确定性推理方法</h1><p>推理：从已知的事实出发，通过运用已掌握的知识，找出其中蕴涵的事实，或归纳出新的事实的过程。</p>
<p>按推出结论的途径：</p>
<ul>
<li><p>演绎推理：一般到个别</p>
</li>
<li><p>归纳推理：个别到一般</p>
</li>
<li><p>默认推理</p>
</li>
</ul>
<p>按推理所用的知识：</p>
<ul>
<li><p>确定性推理</p>
</li>
<li><p>不确定性推理</p>
</li>
</ul>
<p>按推理过程中推出的结论是否越来越接近最终目标：</p>
<ul>
<li><p>单调推理</p>
</li>
<li><p>非单调推理</p>
</li>
</ul>
<p>按推理中是否运用与推理有关的启发性知识：</p>
<ul>
<li><p>启发式推理</p>
</li>
<li><p>非启发式推理</p>
</li>
</ul>
<h2 id="自然演绎推理"><a href="#自然演绎推理" class="headerlink" title="自然演绎推理"></a>自然演绎推理</h2><p>例3.1</p>
<p>设已知如下事实：</p>
<ol>
<li>凡是<strong>容易的</strong>课程小王 (Wang) 都<strong>喜欢</strong>;</li>
<li><strong>C 班的课程</strong>都是<strong>容易的</strong>;</li>
<li>ds<strong>是C班的一门课程</strong>。</li>
</ol>
<p>求证：小王喜欢 ds 这门课程。</p>
<p>证明：</p>
<p>设：<br>$Easy(x)$：x是容易的;<br>$Like(y, x)$：y喜欢 x ;<br>$C(x)$：x是C班的一门课程。</p>
<p>谓词公式集：</p>
<script type="math/tex; mode=display">
(\forall x)(Easy(x)\rightarrow Like(Wang,x))</script><script type="math/tex; mode=display">
(\forall x)(C(x)\rightarrow Easy(x))</script><script type="math/tex; mode=display">
C(ds)</script><p>G：</p>
<script type="math/tex; mode=display">
Like(Wang, ds)</script><p>推理：</p>
<p>全称固化：</p>
<script type="math/tex; mode=display">
Easy(y)\rightarrow Like(Wang,y)</script><p>全称固化：</p>
<script type="math/tex; mode=display">
C(z)\rightarrow Easy(z)</script><p>P规则、假言推理：</p>
<script type="math/tex; mode=display">
C(ds),C(z)\rightarrow Easy(z) \Rightarrow Easy(ds)</script><p>T规则、假言推理：</p>
<script type="math/tex; mode=display">
Easy(ds),Easy(y)\rightarrow Like(Wang,y)\Rightarrow Like(Wang, ds)</script><p>即小王喜欢ds这门课程。</p>
<h2 id="谓词公式集-gt-子句集"><a href="#谓词公式集-gt-子句集" class="headerlink" title="谓词公式集-&gt;子句集"></a>谓词公式集-&gt;子句集</h2><p>原子（atom）谓词公式：一个不能再分解的命题</p>
<p>文字（literal）：原子谓词公式及其否定</p>
<p>子句（clause）：文字的析取式</p>
<p>子句集（set of clauses）：子句构成的集合</p>
<p>空子句（拉丁语nihil）：NIL，不含任何文字的子句。NIL是永假的，不可满足的</p>
<p>转换步骤：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190002594.png" alt=""></p>
<p>例3.2</p>
<p>将下列谓词公式化为子句集</p>
<script type="math/tex; mode=display">
(\forall x)(\ (\forall y)\ P(x,y)\rightarrow \neg (\forall y)\ (Q(x,y)\rightarrow R(x,y)))</script><p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190001458.png" alt=""></p>
<p>例3.3</p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190007357.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190008803.png" alt=""></p>
<p>例3.4</p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190011074.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190011653.png" alt=""></p>
<p>例3.5</p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190012533.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190013861.png" alt=""></p>
<p>谓词公式不可满足$\Leftrightarrow$其子句集不可满足</p>
<h2 id="鲁宾孙归结原理"><a href="#鲁宾孙归结原理" class="headerlink" title="鲁宾孙归结原理"></a>鲁宾孙归结原理</h2><h3 id="命题逻辑中的归结原理"><a href="#命题逻辑中的归结原理" class="headerlink" title="命题逻辑中的归结原理"></a>命题逻辑中的归结原理</h3><p>归结：</p>
<script type="math/tex; mode=display">
C_{12} = (C_1-L_1)\vee (C_2-L_2)</script><p>它类似直接把两式析取，但<strong>和析取的真值表不同</strong>。</p>
<p>定理：</p>
<script type="math/tex; mode=display">
C_1 \wedge C_2 \Rightarrow C_{12}</script><p>推论：</p>
<p>归结出的结论把亲本换掉形成的$S_1$，或者直接塞进原子句集形成的$S_2$，对每一个而言，若它不满足则S不满足。</p>
<h3 id="谓词逻辑中的归结原理"><a href="#谓词逻辑中的归结原理" class="headerlink" title="谓词逻辑中的归结原理"></a>谓词逻辑中的归结原理</h3><script type="math/tex; mode=display">
C_1 = P(x) \vee Q(x)\\
C_2 = \neg P(a) \vee R(y)</script><p>最一般合一</p>
<script type="math/tex; mode=display">
\sigma = \{a/x\}</script><p>相当于$x \cdot a/x = a$，乘了$\sigma$就把$x$全换成$a$</p>
<p>归结：</p>
<p><strong>若$C_1$和$C_2$中没有相同变元</strong>（若有则要改名）、<strong>$C_1$和$C_2$中没有可合一子句</strong>（若有则要先合一）</p>
<p>则</p>
<script type="math/tex; mode=display">
C_{12} = (C_1\sigma - \{L_1\sigma\})\vee (C_2\sigma-\{L_2\sigma\})</script><p>例3.6</p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190023484.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190024139.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190024634.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190024033.png" alt=""></p>
<p>例3.7</p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190026066.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190025553.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190026064.png" alt=""></p>
<p>例3.8</p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190026739.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190027268.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190028485.png" alt=""></p>
<p>因子：$C\sigma$是$C$的因子</p>
<p>单元因子：$C\sigma$是一个单文字</p>
<h3 id="归结反演（证明）"><a href="#归结反演（证明）" class="headerlink" title="归结反演（证明）"></a>归结反演（证明）</h3><p><strong>如果没有归结出空子句，则无法确定S是否可满足。</strong></p>
<p>用之前的反证法，把结论的否定塞进谓词公式集</p>
<p>例3.9</p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190032171.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190032855.png" alt=""></p>
<p>例3.10</p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190033018.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190033066.png" alt=""></p>
<h3 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h3><p>把问题的否定 析取 $ANSWER(variable)$得到$\neg G \vee ANSWER(variable)$，然后将其扔到谓词公式集。</p>
<p>例3.11</p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190035271.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190035154.png" alt=""></p>
<p>例3.12</p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190036403.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190036402.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190036631.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190037231.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205190037208.png" alt=""></p>
<h2 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h2><p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205221357822.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205221357858.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205221358086.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205221359113.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205221359569.png" alt=""></p>
<p>3.1 注意$B,C \Rightarrow B\wedge C$这一步要写出来。</p>
<p>3.2 注意量词的消去规则：从左往右看，逐次缩小域。存在量词若无”$\forall$”约束，则换为常量$a,b,c,\dots$；若有”$\forall variables$”，则换为$skolem$函数$f(variables),g(variables),h(variables),\dots$。</p>
<p>3.4 (3)、(4) 注意谓词连接词的优先级：$\neg \wedge \vee \rightarrow \leftrightarrow$</p>
<p>3.4 (6) 变元太多，可以用大括号把要替换的变元都写出来，然后直接写答案。</p>
<p>3.6 (2) 这里答案很奇怪，我认为是他错了。</p>
<p>3.6 (6) 子句很多，不容易归结。注意<strong>$a$和$f(a)$不能合一</strong>。</p>
<p>3.7 对于这种复杂的证明，要尽可能多地、更准确地设出谓词公式，包括作用的对象，比如$Dolphin(x)$：$x$是海豚。</p>
<p>3.8、3.9：注意结论$G$的表示：</p>
<p>“没有人去储蓄钱”应为$(\forall x)(\forall y)(Money(y)\rightarrow\neg Save(x,y))$，意为：对于任意x、任意y，如果y是钱，那么没有x去储蓄钱y。</p>
<p>“不会有人使用Internet”应为$(\forall x)(\forall y)(Internet(y)\rightarrow\neg Use(x,y))$，意为：对于任意x、任意y，如果y是Internet，那么不会有x使用Internet y。</p>
<h1 id="不确定性推理方法"><a href="#不确定性推理方法" class="headerlink" title="不确定性推理方法"></a>不确定性推理方法</h1><p>知识的静态强度：知识的不确定性程度</p>
<p>知识的动态强度：证据的不确定性程度</p>
<h2 id="可信度方法"><a href="#可信度方法" class="headerlink" title="可信度方法"></a>可信度方法</h2><p>可信度方法：根据经验对一个事物或现象为真的相信程度。</p>
<h3 id="知识不确定性的表示"><a href="#知识不确定性的表示" class="headerlink" title="知识不确定性的表示"></a>知识不确定性的表示</h3><p>C-F（Certainty-Factor）模型中的知识：</p>
<script type="math/tex; mode=display">
IF\qquad E \qquad THEN \qquad H\qquad (CF(H, E))</script><p>其中$CF(H, E)$称可信度因子（certainty factor），是当前提条件$E$为真时，对结论$H$的支持程度。</p>
<p>$CF(H, E) \in [-1,1]$时：小于0代表E支持H为假，等于0代表E与H无关，大于0代表E支持H为真，绝对值越大越支持。</p>
<h3 id="证据不确定性的表示"><a href="#证据不确定性的表示" class="headerlink" title="证据不确定性的表示"></a>证据不确定性的表示</h3><p>$CF(E)=x$：E的可信度为x</p>
<p>静态强度$CF(H, E)$：表示当E对应的证据为真时对H的支持程度</p>
<p>动态强度$CF(E)$：E当前的不确定程度</p>
<h3 id="组合证据不确定性的算法"><a href="#组合证据不确定性的算法" class="headerlink" title="组合证据不确定性的算法"></a>组合证据不确定性的算法</h3><p>当组合证据是多个单一证据的合取时，即：</p>
<script type="math/tex; mode=display">
E=(E_1\quad AND \quad E_2 \quad AND\quad \dots \quad AND \quad E_n)</script><p>若$CF(E_1), CF(E_2), \dots CF(E_n)$已知，则：</p>
<script type="math/tex; mode=display">
CF(E) = min\{ CF(E_1), CF(E_2), \dots CF(E_n) \}</script><p>其实很好理解，如果一个人对你说了关于某一件事的观点和得到这个观点的n个小观点，当你认为其中一个小观点不太可信时，那你就会认为他对这件事的观点不太可信。</p>
<p>当组合证据是多个单一证据的析取时，即：</p>
<script type="math/tex; mode=display">
E=(E_1\quad OR \quad E_2 \quad OR \quad \dots \quad OR \quad E_n)</script><p>若$CF(E_1), CF(E_2), \dots CF(E_n)$已知，则：</p>
<script type="math/tex; mode=display">
CF(E) = max\{ CF(E_1), CF(E_2), \dots CF(E_n) \}</script><p>同样地，n个人对你说了关于某一件事的n个观点，你会相信这n个观点里最可信的一个作为对这件事的观点。</p>
<p>注：理解部分只是暂时写一下，有时间再修改润色。</p>
<h3 id="不确定性的传递算法"><a href="#不确定性的传递算法" class="headerlink" title="不确定性的传递算法"></a>不确定性的传递算法</h3><script type="math/tex; mode=display">
CF(H) = CF(H,E) \times max\{0, CF(E)\}</script><p>就是从$CF(E)\in[-1, 1]$映射到$CF(H)\in[0,1]$。</p>
<h3 id="结论不确定性的合成算法"><a href="#结论不确定性的合成算法" class="headerlink" title="结论不确定性的合成算法"></a>结论不确定性的合成算法</h3><p>若由多条不同知识推出了相同的结论，但可信度不同，则可用合成算法求出综合可信度</p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205191732171.png" alt=""></p>
<p>这个公式其实也很好记，综合可信度$C_{12}$是由$CF_1(H)+CF_2(H)$向0靠近得来的（将$CF_1(H)+CF_2(H)$的绝对值变小）。</p>
<p>对于1. $CF_1(H)+CF_2(H)$为正，$CF_1(H)CF_2(H)$为正，正-正靠近0</p>
<p>对于2. $CF_1(H)+CF_2(H)$为负，$CF_1(H)CF_2(H)$为正，负+正靠近0</p>
<p>对于3. $CF_1(H)+CF_2(H)$不确定，但分母是1-较小值=较大值，所以分式是绝对值较小值</p>
<p>例4.1</p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205191736038.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205191736967.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205191737659.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205191737509.png" alt=""></p>
<h2 id="证据理论"><a href="#证据理论" class="headerlink" title="证据理论"></a>证据理论</h2><h3 id="概率分配函数"><a href="#概率分配函数" class="headerlink" title="概率分配函数"></a>概率分配函数</h3><p>设D为样本空间，D中元素互斥，领域中的命题都用D的子集表示。</p>
<p>基本概率分配函数（Basic Probability Assignment Function）$M:2^D\rightarrow[0,1]$，即对任何一个属于D的子集A，映射到一个数$M\in [0,1]$，且满足：</p>
<script type="math/tex; mode=display">
M(\varnothing)=0 \\
\sum_{A\subset D}M(A)=1</script><p>则称$M$是$2^D$上的基本概率<strong>分配函数</strong>，$M(A)$称为$A$的基本概率<strong>数</strong>。</p>
<h3 id="信任函数"><a href="#信任函数" class="headerlink" title="信任函数"></a>信任函数</h3><p>信任函数（Belief Function）$Bel:2^D\rightarrow[0,1]$，且：</p>
<script type="math/tex; mode=display">
Bel(A)=\sum_{B\subset A}M(B), \forall A \subset D</script><p>Bel函数又称下限函数，Bel(A)表示对命题A为<strong>真</strong>的总信任程度。</p>
<h3 id="似然函数"><a href="#似然函数" class="headerlink" title="似然函数"></a>似然函数</h3><p>似然函数（Plausibility Function）$Pl:2^D\rightarrow[0,1]$，且：</p>
<script type="math/tex; mode=display">
Pl(A) = 1-Bel(\neg A)</script><p>Pl函数又称上限函数、不可驳斥函数，Pl(A)表示对命题A为<strong>非假</strong>的总信任程度。</p>
<h3 id="M正交和"><a href="#M正交和" class="headerlink" title="M正交和"></a>M正交和</h3><p>设$M_1$和$M_2$是两个基本概率分配函数，其正交和$M=M_1\oplus M_2$为：</p>
<script type="math/tex; mode=display">
M(\varnothing)=0 \\
M(A) = \frac{\sum_{x\cap y=A} M_1(x)M_2(y)}{K} \\
K = 1 - \sum_{x\cap y=\varnothing} M_1(x)M_2(y) = \sum_{x\cap y\neq\varnothing} M_1(x)M_2(y)</script><h3 id="不确定性推理"><a href="#不确定性推理" class="headerlink" title="不确定性推理"></a>不确定性推理</h3><p>例4.3</p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205212311976.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205212312585.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205212312165.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205212313360.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205212313119.png" alt=""></p>
<h2 id="模糊推理方法"><a href="#模糊推理方法" class="headerlink" title="模糊推理方法"></a>模糊推理方法</h2><h3 id="模糊集合（fuzzy-sets）"><a href="#模糊集合（fuzzy-sets）" class="headerlink" title="模糊集合（fuzzy sets）"></a>模糊集合（fuzzy sets）</h3><p>论域（Domain of discourse）：所讨论的全体对象称为域。</p>
<p>元素（Element）：论域中的每个对象。</p>
<p>集合（Set）：论域中具有某种相同属性的、确定的、可以彼此区别的元素的全体。</p>
<p>隶属度（Degree of Membership）：描述模糊集合中的每一个元素属于这个模糊集合的强度的一个介于0到1之间的实数。</p>
<p>隶属函数（Membership function）：模糊集合中所有元素的隶属度全体。</p>
<p>表示方法：</p>
<ol>
<li><p>Zadeh表示法：</p>
<p>离散：</p>
<script type="math/tex; mode=display">
A=\mu_A(x_1)/x_1+\mu_A(x_2)/x_2+ \dots + \mu_A(x_n)/x_n = \sum_{i=1}^{n}\mu_A(x_i)/x_i \\ 
A = \{\mu_A(x_1)/x_1, \mu_A(x_2)/x_2, \dots ,  \mu_A(x_n)/x_n\}</script><p>\和+/$\sum$分别表示分隔符、模糊集合整体。</p>
<p>连续：</p>
<script type="math/tex; mode=display">
A =\int_{x\in U}\mu_A(x)/x</script><p>$\int$表示模糊集合整体。</p>
</li>
<li><p>序偶表示法：</p>
<script type="math/tex; mode=display">
A = \{(\mu_A(x_1), x_1), (\mu_A(x_2),x_2), \dots ,  (\mu_A(x_n),x_n)\}</script></li>
<li><p>向量表示法：</p>
<script type="math/tex; mode=display">
A = [\mu_A(x_1), \mu_A(x_2), \dots ,  \mu_A(x_n)]</script></li>
</ol>
<h3 id="模糊集合的运算"><a href="#模糊集合的运算" class="headerlink" title="模糊集合的运算"></a>模糊集合的运算</h3><p>包含：若$\mu_A(x)\geq \mu_B(x)$，则$A\supset B$</p>
<p>相等：若$\mu_A(x)= \mu_B(x)$，则$A= B$</p>
<p>交：$\mu_{A\cap B}(x)=min{\mu_A(x), \mu_B(x)}=\mu_A(x)\wedge\mu_B(x)$</p>
<p>并：$\mu_{A\cup B}(x)=max{\mu_A(x), \mu_B(x)}=\mu_A(x)\vee\mu_B(x)$</p>
<p>补：$\mu_{\overline{A}}(x)=1-\mu_A(x)$</p>
<p>代数积：$\mu_{A\cdot B}(x)=\mu_A(x)\mu_B(x)$</p>
<p>代数和：<script type="math/tex">\mu_{A+B}(x)=\mu_A(x)+\mu_B(x)-\mu_{A\cdot B}(x)</script></p>
<p>有界和：$\mu_{A\oplus B}(x) = min{1,\mu_A(x)+\mu_B(x)}$</p>
<p>有界积：$\mu_{A\otimes B}(x) = max{0,\mu_A(x)+\mu_B(x)-1}$</p>
<p>注：下方的$\mu$和$R$应为粗体，代表向量和矩阵，我暂时不会打。</p>
<p>叉积：$R = \mu_{A\times B}(a,b) = \mu_A^\mathrm{T}\circ\mu_B$</p>
<p>$\circ$为模糊向量最小乘积</p>
<p>模糊关系R合成：$S = Q \circ R$</p>
<p>$\circ$有两种常用计算方法：</p>
<ol>
<li>最小-最大合成法：在矩阵乘法的基础上，将乘积换为取小、求和换为取大；</li>
<li>代数积-最大合成法：在矩阵乘法的基础上，将乘积换为代数积、求和换为取大。</li>
</ol>
<h3 id="模糊推理"><a href="#模糊推理" class="headerlink" title="模糊推理"></a>模糊推理</h3><p>模糊知识表示：</p>
<script type="math/tex; mode=display">
(<对象>, <属性>, (<属性值>, <隶属度>))</script><p>模糊规则推理：</p>
<p>已知$A$、$B$、$A’$，求$B’$</p>
<script type="math/tex; mode=display">
R = A \times B \\
B' = A' \circ R</script><h3 id="模糊决策"><a href="#模糊决策" class="headerlink" title="模糊决策"></a>模糊决策</h3><p>模糊决策：将模糊推理得到的模糊向量转化为确定值的过程。</p>
<ol>
<li><p>最大隶属度法</p>
<script type="math/tex; mode=display">
U = u_i\quad,\mu(u_i)=max\{\mu\}</script></li>
<li><p>加权平均判决法</p>
<script type="math/tex; mode=display">
U = \frac{\sum_{i = 1}^{n}\mu(u_i)u_i}{\sum_{i = 1}^{n}\mu(u_i)}</script></li>
<li><p>中位数法</p>
<script type="math/tex; mode=display">
\sum_{u_1}^{U}\mu(u_i)=\sum_{U+1}^{u_n}\mu(u_i)</script><p>注：可以先计算sum/2，当累加到最接近该值的$\mu(u_i)$时，$U = u_i$。</p>
</li>
</ol>
<h3 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h3><p>例4.10</p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205220007370.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205220011172.jpg" alt=""></p>
<p>注：右边是女朋友画的。</p>
<h2 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h2><p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205221702056.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205221702381.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205221703485.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205221703015.png" alt=""></p>
<p>4.2 初始可信度需要参与合成。</p>
<p>4.3 本题中的推理网络还蛮好用，不过没在正文中出现。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205222247002.png" alt=""></p>
<p>4.9 极小-极大算法可以用“打擂法”在脑中遍历一次直接得出结果。</p>
<h1 id="搜索求解策略"><a href="#搜索求解策略" class="headerlink" title="搜索求解策略"></a>搜索求解策略</h1><h2 id="搜索的概念"><a href="#搜索的概念" class="headerlink" title="搜索的概念"></a>搜索的概念</h2><p>盲目搜索（Blind search）：在对特定问题不具有任何有关信息的条件下，按固定的步骤（依次或随机调用操作算子）进行的搜索。</p>
<p>启发式搜索（Heuristic search）：考虑特定问题领域可应用的知识，动态地确定调用操作算子的步骤，优先选择较合适的操作算子，以求减少不必要的搜索、尽快达到结束状态、提高搜索效率的搜索。</p>
<h2 id="状态空间的搜索策略"><a href="#状态空间的搜索策略" class="headerlink" title="状态空间的搜索策略"></a>状态空间的搜索策略</h2><p>状态空间：利用状态变量和操作符号，表示系统或问题的有关知识的符号体系。</p>
<script type="math/tex; mode=display">
(S,O,S_0,G)</script><p>$S$：状态集合</p>
<p>$O$：操作算子的集合</p>
<p>$S_0$：初始状态</p>
<p>$G$：目的状态</p>
<p>求解路径：从$S_0$结点到$G$结点的路径</p>
<script type="math/tex; mode=display">
S_0 \xrightarrow[]{O_1} S_1 \xrightarrow[]{O_2} S_2 \xrightarrow[]{O_3} \dots \xrightarrow[]{O_k} G</script><p>解：求解路径上的操作算子序列</p>
<script type="math/tex; mode=display">
O_1,O_2, \dots , O_k</script><h2 id="盲目的图搜索策略"><a href="#盲目的图搜索策略" class="headerlink" title="盲目的图搜索策略"></a>盲目的图搜索策略</h2><h3 id="回溯策略"><a href="#回溯策略" class="headerlink" title="回溯策略"></a>回溯策略</h3><p>回溯（Backtracking）</p>
<p>数据结构：</p>
<p>路径状态表（Path States Table, PS）：保存当前搜索路径上的状态。</p>
<p>新的路径状态表（New Path States Table, NPS）：保存等待搜索的状态。</p>
<p>不可解状态表（No Solvable States Table, NSS）：保存找不到解路径的状态。</p>
<p>当前正在被遍历的状态（Current State, CS）：当前正在被遍历的状态（hhhh废话）。</p>
<h3 id="宽度优先搜索策略"><a href="#宽度优先搜索策略" class="headerlink" title="宽度优先搜索策略"></a>宽度优先搜索策略</h3><p>宽度优先搜索（Breadth-First Search）</p>
<p>数据结构：</p>
<p>open表：NPS表，保存已生成但未被遍历的状态。</p>
<p>closed表：PS表和NSS表，保存已遍历的状态。</p>
<p>Pascal伪代码描述：</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Procedure</span> <span class="title">breadth_first_search</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function"><span class="title">open</span> :</span>= [S0];			<span class="comment">// 队列</span></span><br><span class="line">closed := [];			<span class="comment">// 栈</span></span><br><span class="line"><span class="keyword">while</span> open != [] <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		从open表中删除第一个状态，赋给n;</span><br><span class="line">		将n放入closed表中;</span><br><span class="line">		<span class="keyword">if</span> n = G <span class="keyword">then</span> return (success);</span><br><span class="line">		生成n的所有子状态;</span><br><span class="line">		从n的所有子状态中删除已在open表或closed表中出现的状态;</span><br><span class="line">		将n的剩余子状态，按生成次序加入open表的后段;</span><br><span class="line">	<span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h3 id="深度优先搜索策略"><a href="#深度优先搜索策略" class="headerlink" title="深度优先搜索策略"></a>深度优先搜索策略</h3><p>深度优先搜索（Depth-First Search）</p>
<p>数据结构：</p>
<p>open表：NPS表，保存已生成但未被遍历的状态。</p>
<p>closed表：PS表和NSS表，保存已遍历的状态。</p>
<p>Pascal伪代码描述：</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Procedure</span> <span class="title">breadth_first_search</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function"><span class="title">open</span> :</span>= [S0];			<span class="comment">// 栈</span></span><br><span class="line">closed := [];			<span class="comment">// 栈</span></span><br><span class="line"><span class="keyword">while</span> open != [] <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		从open表中删除第一个状态，赋给n;</span><br><span class="line">		将n放入closed表中;</span><br><span class="line">		<span class="keyword">if</span> n = G <span class="keyword">then</span> return (success);</span><br><span class="line">		<span class="keyword">if</span> n的深度 &lt; depth_limit <span class="keyword">then</span> <span class="keyword">continue</span>;</span><br><span class="line">		生成n的所有子状态;</span><br><span class="line">		从n的所有子状态中删除已在open表或closed表中出现的状态;</span><br><span class="line">		将n的剩余子状态，按生成次序加入open表的前段;</span><br><span class="line">	<span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p>注：这一节书上讲的很差，建议去算法方面的书学习这里。我要是还有时间会补这里的。</p>
<h2 id="启发式图搜索策略"><a href="#启发式图搜索策略" class="headerlink" title="启发式图搜索策略"></a>启发式图搜索策略</h2><h3 id="启发式策略"><a href="#启发式策略" class="headerlink" title="启发式策略"></a>启发式策略</h3><p>启发式策略利用启发信息引导搜索。</p>
<p>启发信息：与问题有关的信息。</p>
<p>例5.6 井字棋</p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205221732831.png" alt=""></p>
<p>采用启发式策略，搜索树如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205221947727.png" alt=""></p>
<p>其实这种启发式策略很简单，就是将净赢状态数作为启发值，搜索启发值最大的那个/那些状态。</p>
<p>以第一步为例（X方回合）：</p>
<p>首先缩减状态空间，可以看出共有3种不同的落子处（类似魔方中的角块、棱块、中心块）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205221952375.png" alt=""></p>
<p>既然井字棋的规则是只要没被对方棋占住的空格就都可以下，那么以(a)图为例，X方的赢状态数共有8种。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205221957419.png" alt=""></p>
<p>那么下完这步后，O方的赢状态数共有5种。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WanpengXu/myPicGo/img/202205222000079.png" alt=""></p>
<p>所以X方若下在角块处，净赢状态数共有8-5=3种，而下在中心块有8-4=4种，所以依启发式策略，第一步搜索了X方下在中心块的状态。</p>
<h3 id="启发信息和估价函数"><a href="#启发信息和估价函数" class="headerlink" title="启发信息和估价函数"></a>启发信息和估价函数</h3><h3 id="A搜索算法"><a href="#A搜索算法" class="headerlink" title="A搜索算法"></a>A搜索算法</h3><h3 id="A-搜索算法"><a href="#A-搜索算法" class="headerlink" title="A*搜索算法"></a>A*搜索算法</h3><h1 id="智能计算及其应用"><a href="#智能计算及其应用" class="headerlink" title="智能计算及其应用"></a>智能计算及其应用</h1><p>注：这一章后面就进入机器学习部分了，所以到这里人工智能的基本知识就结束了，后面看西瓜书就可以了。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>许</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://xuwp.top/Introduction-to-Artificial-Intelligence.html">http://xuwp.top/Introduction-to-Artificial-Intelligence.html</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2022 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"># 人工智能</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/computer-based-Exam.html">Computer-Based Exam</a>
            
            
            <a class="next" rel="next" href="/Writing-Skills-Improvement-Tools.html">写作能力提升——工具篇</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>Stay hungry. Stay foolish.</span>
    </div>
</footer>

    </div>
</body>

</html>